
// This source file was auto-generated by ClassMate++
// Created: 9 Aug 2020 3:08:12 pm
// Copyright (c) 2020, HurleyWorks

// much of this code comes from https://github.com/shocker-0x15/OptiX7_Utility

// dtor
PipelineHandler::~PipelineHandler()
{
    try
    {
        shaderBindingTable.finalize();
        shadingHitProgramGroup.destroy();
        missProgram.destroy();
        rayGenProgram.destroy();
        moduleOptiX.destroy();
        pipeline.destroy();
        optixContext.destroy();

        CUDADRV_CHECK (cuStreamDestroy (cuStream));
        CUDADRV_CHECK (cuCtxDestroy (cuContext));
    }
    catch (std::exception& e)
    {
        LOG (CRITICAL) << e.what();
    }
    catch (...)
    {
        LOG (CRITICAL) << "Caught unknown exception!";
    }
}

void PipelineHandler::initialize()
{
    CUDADRV_CHECK (cuInit (0));
    CUDADRV_CHECK (cuDeviceGetCount (&cuDeviceCount));
    CUDADRV_CHECK (cuCtxCreate (&cuContext, 0, 0));
    CUDADRV_CHECK (cuCtxSetCurrent (cuContext));
    CUDADRV_CHECK (cuStreamCreate (&cuStream, 0));
   

    optixContext = optixu::Context::create (cuContext);
}

void PipelineHandler::setPipeline (const std::string& ptxFolder, RenderMode pipelineType, bool enableMotionBlur)
{
    pipeline.destroy();

    motionBlur = enableMotionBlur;
    this->pipelineType = pipelineType;
    this->ptxFolder = ptxFolder;

    switch (pipelineType)
    {
        case RenderMode::PathTracer:
            createPathtracerPipeline (ptxFolder);
            break;

        default:
            break;
    }

    pipeline.generateShaderBindingTableLayout (&sbtSize);
    shaderBindingTable.initialize (cuContext, cudau::BufferType::Device, sbtSize, 1);
    pipeline.setShaderBindingTable (&shaderBindingTable);
}

void PipelineHandler::createPathtracerPipeline (const std::string& ptxFolder)
{
    pipeline = optixContext.createPipeline();
    pipeline.setPipelineOptions (8, 2, "plp", sizeof (PathTracerShared::PipelineLaunchParameters),
                                 false, OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_LEVEL_INSTANCING,
                                 OPTIX_EXCEPTION_FLAG_STACK_OVERFLOW | OPTIX_EXCEPTION_FLAG_TRACE_DEPTH |
                                     OPTIX_EXCEPTION_FLAG_DEBUG,
                                 OPTIX_PRIMITIVE_TYPE_FLAGS_TRIANGLE);

    const std::string ptxPath = ptxFolder + "/pathtracer_kernels.cu.ptx";
    const std::string ptx = readTxtFile (ptxPath);
    if (!ptx.length()) throw std::runtime_error ("Failed to load ptx file at: " + ptxPath);

    moduleOptiX = pipeline.createModuleFromPTXString (
        ptx, OPTIX_COMPILE_DEFAULT_MAX_REGISTER_COUNT,
        OPTIX_COMPILE_OPTIMIZATION_DEFAULT,
        DEBUG_SELECT (OPTIX_COMPILE_DEBUG_LEVEL_LINEINFO, OPTIX_COMPILE_DEBUG_LEVEL_NONE));

    // CUDADRV_CHECK (cuModuleLoad (&moduleCopyBuffers, (getExecutableDirectory() / "denoiser/ptxes/copy_buffers.ptx").string().c_str()));
    ;

    rayGenProgram = pipeline.createRayGenProgram (moduleOptiX, RT_RG_NAME_STR ("pathTracing"));
    //optixu::ProgramGroup exceptionProgram = pipeline.createExceptionProgram(moduleOptiX, "__exception__print");
    missProgram = pipeline.createMissProgram (moduleOptiX, RT_MS_NAME_STR ("miss"));
    emptyMissProgram = pipeline.createMissProgram (emptyModule, nullptr);

    shadingHitProgramGroup = pipeline.createHitProgramGroup (
        moduleOptiX, RT_CH_NAME_STR ("shading"),
        emptyModule, nullptr,
        emptyModule, nullptr);
    visibilityHitProgramGroup = pipeline.createHitProgramGroup (
        emptyModule, nullptr,
        moduleOptiX, RT_AH_NAME_STR ("visibility"),
        emptyModule, nullptr);

    //pipeline.setMaxTraceDepth (2);
    uint32_t maxTraceDepth = 2;
    pipeline.link (maxTraceDepth, DEBUG_SELECT (OPTIX_COMPILE_DEBUG_LEVEL_FULL, OPTIX_COMPILE_DEBUG_LEVEL_NONE));

    pipeline.setRayGenerationProgram (rayGenProgram);
    // If an exception program is not set but exception flags are set, the default exception program will by provided by OptiX.
    //pipeline.setExceptionProgram(exceptionProgram);
    pipeline.setNumMissRayTypes (PathTracerShared::NumRayTypes);
    pipeline.setMissProgram (PathTracerShared::RayType_Search, missProgram);
    pipeline.setMissProgram (PathTracerShared::RayType_Visibility, emptyMissProgram);
}
