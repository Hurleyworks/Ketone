// This header file was auto-generated by ClassMate++
// Created: 20 Aug 2020 7:42:04 pm
// Copyright (c) 2020, HurleyWorks

#pragma once

using sabi::RenderableNode;
using sabi::Surfaces;

class MaterialHandler
{
 public:
    using OptixMaterials = std::vector<optixu::Material>;
    using MaterialSets = std::vector<OptixMaterials>;
    using MaterialMap = std::unordered_map<RenderableNode, MaterialSets>;
    using MaterialIndexBuffer = cudau::TypedBuffer<uint32_t>;
    using MaterialIndexBufferRef = std::shared_ptr<MaterialIndexBuffer>;
    using MaterialIndexBuffers = std::vector<MaterialIndexBufferRef>;

 public:
    MaterialHandler() = default;
    ~MaterialHandler() = default;

    void initialize (MoojiStateRef& state) { this->state = state; }
    void createOptixMaterials (RenderableNode& node);
    uint32_t addRenderableMaterials (GeometryInstanceRef& geomInst, RenderableNode& node);

    const MaterialSets& getMaterialSets (RenderableNode& node)
    {
        auto it = materialMap.find (node);
        return it == materialMap.end() ? emptySet : it->second;
    }

 private:
    MoojiStateRef state = nullptr;
    MaterialMap materialMap;
    MaterialSets emptySet;

    MaterialIndexBuffers matIndxBuffers;
    std::vector<uint32_t> matIndices;

    void addRandomMaterialSet (OptixMaterials& matSet, const Surfaces& surfs);

}; // end class MaterialHandler
