
// This source file was auto-generated by ClassMate++
// Created: 8 Sep 2020 8:44:40 pm
// Copyright (c) 2020, HurleyWorks

// ctor
SceneHandler::SceneHandler (OptiXStateRef state) :
    state (state)
{
}

// dtor
SceneHandler::~SceneHandler()
{
}

void SceneHandler::addInstance (RenderableNode& node, InstanceRef& inst, PipelineHandlerRef& pipeline)
{
    GroupRef topGroup = state->groups.size() ? state->groups[0] : createTopGroup();
    topGroup->insts.push_back (inst);
    topGroup->optixIAS.addChild (inst->optixInst);
    inst->parentGroups.insert (topGroup);

    traversablesUpdated = true;
    hitGroupSbtLayoutUpdated = true;

    updateState (pipeline);
}

GroupRef SceneHandler::createTopGroup()
{
    GroupRef topGroup = make_shared_with_deleter<Group> (Group::finalize);
    topGroup->optixEnv = state.get();
    uint32_t serialID = state->iasSerialID++;

    char name[256];
    sprintf_s (name, "IAS-%u", serialID);
    topGroup->serialID = serialID;
    topGroup->name = name;
    topGroup->optixIAS = state->scene.createInstanceAccelerationStructure();
    topGroup->optixIAS.setConfiguration (optixu::ASTradeoff::PreferFastTrace, true, false);

    state->groups[serialID] = topGroup;

    return topGroup;
}

void SceneHandler::updateState (PipelineHandlerRef& pipeline, bool updateSBT)
{
    hitGroupSbtLayoutUpdated = updateSBT;
    if (state->groups.size())
        state->groups[0]->optixIAS.markDirty();

    for (const auto& it : state->geomGroups)
    {
        const GeometryGroupRef& geomGroup = it.second;
        if (geomGroup->optixGAS.isReady())
            continue;

        OptixAccelBufferSizes bufferSizes;
        geomGroup->optixGAS.prepareForBuild (&bufferSizes);
        if (bufferSizes.tempSizeInBytes >= state->asScratchBuffer.sizeInBytes())
            state->asScratchBuffer.resize (bufferSizes.tempSizeInBytes, 1, state->cuStream);

        LOG (DBUG) << "GAS: " << it.second->name;
        LOG (DBUG) << "AS Size: " << bufferSizes.outputSizeInBytes;
        LOG (DBUG) << "Scratch Size: " << bufferSizes.tempSizeInBytes;

        // EN: It is dangerous to reallocate AS memory during the GPU is using it,
        //     so wait the completion of use.
        //     You need to prepare a completely separated buffer and switch the current with it
        //     if you don't want to interfere CPU/GPU asynchronous execution.
        if (geomGroup->optixGasMem.isInitialized())
        {
            if (bufferSizes.outputSizeInBytes > geomGroup->optixGasMem.sizeInBytes())
            {
                CUDADRV_CHECK (cuStreamSynchronize (state->cuStream));
                geomGroup->optixGasMem.resize (bufferSizes.outputSizeInBytes, 1, state->cuStream);
            }
        }
        else
        {
            CUDADRV_CHECK (cuStreamSynchronize (state->cuStream));
            geomGroup->optixGasMem.initialize (state->cuContext, g_bufferType, bufferSizes.outputSizeInBytes, 1);
        }
        geomGroup->optixGAS.rebuild (state->cuStream, getView (geomGroup->optixGasMem), getView (state->asScratchBuffer));
    }

    if (hitGroupSbtLayoutUpdated)
    {
        sbtIndex = (sbtIndex + 1) % 2;
        curHitGroupSBT = &state->hitGroupSBT[sbtIndex];

        size_t hitGroupSbtSize;
        state->scene.generateShaderBindingTableLayout (&hitGroupSbtSize);
        if (curHitGroupSBT->isInitialized())
        {
            curHitGroupSBT->resize (hitGroupSbtSize, 1, state->cuStream);
        }
        else
        {
            curHitGroupSBT->initialize (state->cuContext, g_bufferType, hitGroupSbtSize, 1);
            curHitGroupSBT->setMappedMemoryPersistent (true);
        }
        pipeline->pl().setHitGroupShaderBindingTable (getView (*curHitGroupSBT), curHitGroupSBT->getMappedPointer());
        hitGroupSbtLayoutUpdated = false;
    }

    for (const auto& it : state->groups)
    {
        const GroupRef& group = it.second;
        if (group->optixIAS.isReady())
            continue;

        OptixAccelBufferSizes bufferSizes;
        uint32_t numInstances;
        group->optixIAS.prepareForBuild (&bufferSizes, &numInstances);
        LOG(DBUG) << "IAS: ", it.second->name;
        LOG(DBUG) << "AS Size in bytes: " <<  bufferSizes.outputSizeInBytes;
        LOG(DBUG) << "Scratch Size in bytes: " << bufferSizes.tempSizeInBytes;

        if (bufferSizes.tempSizeInBytes >= state->asScratchBuffer.sizeInBytes())
            state->asScratchBuffer.resize (bufferSizes.tempSizeInBytes, 1, state->cuStream);
        
        // EN: It is dangerous to reallocate AS memory during the GPU is using it,
        //     so wait the completion of use.
        //     You need to prepare a completely separated buffer and switch the current with it
        //     if you don't want to interfere CPU/GPU asynchronous execution.
        if (group->optixIasMem.isInitialized())
        {
            if (bufferSizes.outputSizeInBytes > group->optixIasMem.sizeInBytes() ||
                numInstances > group->optixInstanceBuffer.numElements())
            {
                CUDADRV_CHECK (cuStreamSynchronize (state->cuStream));
                group->optixIasMem.resize (bufferSizes.outputSizeInBytes, 1, state->cuStream);
                group->optixInstanceBuffer.resize (numInstances);
            }
        }
        else
        {
            CUDADRV_CHECK (cuStreamSynchronize (state->cuStream));
            group->optixIasMem.initialize (state->cuContext, g_bufferType, bufferSizes.outputSizeInBytes, 1);
            group->optixInstanceBuffer.initialize (state->cuContext, g_bufferType, numInstances);
        }
        group->optixIAS.rebuild (state->cuStream, getView (group->optixInstanceBuffer), getView (group->optixIasMem), getView (state->asScratchBuffer));
    }

    traversablesUpdated = false;
}
