// This source file was auto-generated by ClassMate++
// Created: 9 Aug 2020 3:08:12 pm
// Copyright (c) 2020, HurleyWorks

// much of this code comes from https://github.com/shocker-0x15/OptiX7_Utility

// dtor
DenoisingHandler::~DenoisingHandler()
{
    accumBuffer.finalize();
}

void DenoisingHandler::initialize (MoojiStateRef& state, uint32_t renderWidth, uint32_t renderHeight)
{
    this->state = state;

    CUDADRV_CHECK (cuModuleLoad (&moduleCopyBuffers, (state->engine.getPtxFolder() + "/copy_buffers.cu.ptx").c_str()));
    kernelCopyBuffers.set (moduleCopyBuffers, "copyBuffers", cudau::dim3 (8, 8), 0);

    CUcontext& cuContext = state->engine.cuCtx();

    colorAccumBuffer.initialize2D (cuContext, cudau::ArrayElementType::Float32, 4,
                                   cudau::ArraySurface::Enable, cudau::ArrayTextureGather::Disable,
                                   renderWidth, renderHeight, 1);
    albedoAccumBuffer.initialize2D (cuContext, cudau::ArrayElementType::Float32, 4,
                                    cudau::ArraySurface::Enable, cudau::ArrayTextureGather::Disable,
                                    renderWidth, renderHeight, 1);
    normalAccumBuffer.initialize2D (cuContext, cudau::ArrayElementType::Float32, 4,
                                    cudau::ArraySurface::Enable, cudau::ArrayTextureGather::Disable,
                                    renderWidth, renderHeight, 1);

    linearColorBuffer.initialize (cuContext, cudau::BufferType::Device,
                                  renderWidth * renderHeight);
    linearAlbedoBuffer.initialize (cuContext, cudau::BufferType::Device,
                                   renderWidth * renderHeight);
    linearNormalBuffer.initialize (cuContext, cudau::BufferType::Device,
                                   renderWidth * renderHeight);
    linearOutputBuffer.initialize (cuContext, cudau::BufferType::Device,
                                   renderWidth * renderHeight);

    tileWidth = useTiledDenoising ? 32 : 0;
    tileHeight = useTiledDenoising ? 32 : 0;
    denoiser = state->engine.optCtx().createDenoiser (OPTIX_DENOISER_INPUT_RGB_ALBEDO_NORMAL);
    denoiser.setModel (OPTIX_DENOISER_MODEL_KIND_HDR, nullptr, 0);
    denoiser.prepare (renderWidth, renderHeight, tileWidth, tileHeight,
                      &stateSize, &scratchSize, &scratchSizeForComputeIntensity,
                      &numTasks);

    denoiserStateBuffer.initialize (cuContext, cudau::BufferType::Device, stateSize, 1);
    denoiserScratchBuffer.initialize (cuContext, cudau::BufferType::Device,
                                      std::max (scratchSize, scratchSizeForComputeIntensity), 1);

    LOG (INFO) << "Denoiser State Buffer: " << denoiserStateBuffer.sizeInBytes();
    LOG (INFO) << "Denoiser Scratch Buffer: ", denoiserScratchBuffer.sizeInBytes();

    denoisingTasks.resize (numTasks);
    denoiser.getTasks (denoisingTasks.data());

    // It is possible to reuse the scratch buffer for denoising for computeIntensity() if its size is enough.
    denoiser.setLayers (&linearColorBuffer, &linearAlbedoBuffer, &linearNormalBuffer, &linearOutputBuffer,
                        OPTIX_PIXEL_FORMAT_FLOAT4, OPTIX_PIXEL_FORMAT_FLOAT4, OPTIX_PIXEL_FORMAT_FLOAT4);
    denoiser.setupState (state->engine.stream(), denoiserStateBuffer, denoiserScratchBuffer);

    dimCopyBuffers = kernelCopyBuffers.calcGridDim (renderWidth, renderHeight);

    CUDADRV_CHECK (cuMemAlloc (&hdrIntensity, sizeof (float)));
}

void DenoisingHandler::update (CUstream& curCuStream, int32_t renderWidth, int32_t renderHeight)
{
    // EN: Copy the results to the linear buffers (and normalize normals).
    kernelCopyBuffers (curCuStream, dimCopyBuffers,
                       colorAccumBuffer.getSurfaceObject (0),
                       albedoAccumBuffer.getSurfaceObject (0),
                       normalAccumBuffer.getSurfaceObject (0),
                       linearColorBuffer.getDevicePointer(),
                       linearAlbedoBuffer.getDevicePointer(),
                       linearNormalBuffer.getDevicePointer(),
                       uint2 (renderWidth, renderHeight));

    denoiser.computeIntensity (curCuStream, denoiserScratchBuffer, hdrIntensity);
    for (int i = 0; i < denoisingTasks.size(); ++i)
        denoiser.invoke (curCuStream, false, hdrIntensity, 0.0f, denoisingTasks[i]);
}

void DenoisingHandler::getRender (PixelBuffer& pixels, RenderOutput outputType)
{
    // EN: Output the result and buffers associated to the denoiser as images.
    auto colorPixels = colorAccumBuffer.map<float4>();
    auto albedoPixels = albedoAccumBuffer.map<float4>();
    auto normalPixels = normalAccumBuffer.map<float4>();
    auto outputPixels = linearOutputBuffer.map();
    int i = 0;

    for (int y = 0; y < pixels.spec.height; ++y)
    {
        for (int x = 0; x < pixels.spec.width; ++x)
        {
            uint32_t linearIndex = pixels.spec.width * y + x;

            float4 color = colorPixels[linearIndex];
            color.x = sRGB_gamma_s (1 - std::exp (-color.x));
            color.y = sRGB_gamma_s (1 - std::exp (-color.y));
            color.z = sRGB_gamma_s (1 - std::exp (-color.z));

            if (outputType == RenderOutput::Color)
                pixels.floatPixels.col (i++) = Eigen::Vector4f (color.x, color.y, color.z, color.w);

            float4 albedo = albedoPixels[linearIndex];
            if (outputType == RenderOutput::Albedo)
                pixels.floatPixels.col (i++) = Eigen::Vector4f (albedo.x, albedo.y, albedo.z, albedo.w);

            float4 normal = normalPixels[linearIndex];
            if (outputType == RenderOutput::Normal)
                pixels.floatPixels.col (i++) = Eigen::Vector4f (normal.x, normal.y, normal.z, normal.w);

            float4 output = outputPixels[linearIndex];
            output.x = sRGB_gamma_s (1 - std::exp (-output.x));
            output.y = sRGB_gamma_s (1 - std::exp (-output.y));
            output.z = sRGB_gamma_s (1 - std::exp (-output.z));
            if (outputType == RenderOutput::ColorDenoised)
                pixels.floatPixels.col (i++) = Eigen::Vector4f (output.x, output.y, output.z, output.w);
        }
    }
    linearOutputBuffer.unmap();
    normalAccumBuffer.unmap();
    albedoAccumBuffer.unmap();
    colorAccumBuffer.unmap();
}
