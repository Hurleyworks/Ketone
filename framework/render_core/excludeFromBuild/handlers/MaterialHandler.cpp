
// This source file was auto-generated by ClassMate++
// Created: 8 Sep 2020 8:44:40 pm
// Copyright (c) 2020, HurleyWorks

// ctor
MaterialHandler::MaterialHandler (OptiXStateRef state) :
    state (state)
{
}

// dtor
MaterialHandler::~MaterialHandler()
{
}

uint32_t MaterialHandler::addRenderableMaterials (RenderableNode& node, GeometryInstanceRef& geomInst, PipelineHandlerRef& pipeline)
{
    createOptixMaterials (node, pipeline);

    const MaterialHandler::MaterialSets& matSets = getMaterialSets (node);
    jassert (matSets.size());
    uint32_t materialCount = matSets[0].size();

    auto mesh = node->getMesh();
    uint32_t triangleCount = mesh->triangleCount();

    MaterialIndexBufferRef matIndexBuffer = std::make_shared<MaterialIndexBuffer>();

    matIndices.clear();
    if (materialCount > 1)
    {
        matIndices.reserve (triangleCount);

        uint32_t materialIndex = 0;
        for (auto& S : mesh->S)
        {
            uint32_t triCount = S.triangleCount();
            for (int i = 0; i < triCount; i++)
                matIndices.push_back (materialIndex);

            ++materialIndex;
        }

        matIndexBuffer->initialize (state->cuContext, cudau::BufferType::Device, matIndices);
        geomInst->optixGeomInst.setNumMaterials (materialCount, getView (*matIndexBuffer.get()), sizeof (uint32_t));

        matIndxBuffers.push_back (matIndexBuffer);
    }
    else
    {
        geomInst->optixGeomInst.setNumMaterials (1, optixu::BufferView());
    }

    uint32_t i = 0;
    for (const auto& set : matSets)
    {
        uint32_t j = 0;
        for (const auto& mat : set)
        {
            geomInst->optixGeomInst.setMaterial (i, j, mat);
            geomInst->optixGeomInst.setGeometryFlags (j, OPTIX_GEOMETRY_FLAG_NONE);
            ++j;
        }

        ++i;
    }

    return matSets.size();
}

void MaterialHandler::addRandomMaterialSet (OptixMaterials& matSet, const Surfaces& surfs, PipelineHandlerRef& pipeline)
{
    matSet.reserve (surfs.size());

    for (const auto& s : surfs)
    {
        const sabi::Material& m = s.getMaterial();

        optixu::Material mat = state->optixContext.createMaterial();
        mat.setHitGroup (pipeline->getSearchRayType(), pipeline->getHitGroup());

        Shared::MaterialData matData = {};
        auto r1 = RandoM::get<RandoM::common> (1, 0.f);
        auto r2 = RandoM::get<RandoM::common> (1, 0.f);
        auto r3 = RandoM::get<RandoM::common> (1, 0.f);

        matData.albedo = make_float3 (sRGB_degamma_s (m.base_color.x() * r1), sRGB_degamma_s (m.base_color.y() * r2), sRGB_degamma_s (m.base_color.z() * r3));
        mat.setUserData (matData);
        matSet.push_back (mat);
    }
}

void MaterialHandler::createOptixMaterials (RenderableNode& node, PipelineHandlerRef& pipeline)
{
    MaterialSets sets;

    const auto& mesh = node->getMesh();

    OptixMaterials surfaceSet;
    surfaceSet.reserve (mesh->S.size());

    OptixMaterials selectSet;
    selectSet.reserve (mesh->S.size());

    for (auto& S : mesh->S)
    {
        uint32_t matIndex = state->materialID++;

        sabi::Material& m = S.getMaterial();
        m.setIndex (matIndex);

        // surface material
        optixu::Material surfaceMat = state->optixContext.createMaterial();
        surfaceMat.setHitGroup (pipeline->getSearchRayType(), pipeline->getHitGroup());

        Shared::MaterialData surfaceData = {};
        surfaceData.albedo = make_float3 (sRGB_degamma_s (m.base_color.x()), sRGB_degamma_s (m.base_color.y()), sRGB_degamma_s (m.base_color.z()));

        surfaceMat.setUserData (surfaceData);
        surfaceSet.push_back (surfaceMat);

        // selected material
        optixu::Material selectionMat = state->optixContext.createMaterial();
        selectionMat.setHitGroup (pipeline->getSearchRayType(), pipeline->getHitGroup());

        Shared::MaterialData selectionData = {};
        // FIXME selection color is orange
        selectionData.albedo = make_float3 (sRGB_degamma_s (1.0f), sRGB_degamma_s (0.5f), sRGB_degamma_s (0.0f));
        selectionMat.setUserData (selectionData);
        selectSet.push_back (selectionMat);
    }

    sets.push_back (surfaceSet);
    sets.push_back (selectSet);

    for (int i = 0; i < RANDOM_MATERIAL_COUNT; i++)
    {
        OptixMaterials random;
        addRandomMaterialSet (random, mesh->S, pipeline);
        sets.push_back (random);
    }

    materialMap.insert (std::make_pair (node, sets));
}