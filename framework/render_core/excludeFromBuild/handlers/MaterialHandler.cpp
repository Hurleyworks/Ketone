// This source file was auto-generated by ClassMate++
// Created: 20 Aug 2020 7:42:04 pm
// Copyright (c) 2020, HurleyWorks


// much of this code comes from https://github.com/shocker-0x15/OptiX7_Utility


void MaterialHandler::createOptixMaterials (RenderableNode& node)
{
    MaterialSets sets;

    const auto& mesh = node->getMesh();

    OptixMaterials surfaceSet;
    surfaceSet.reserve (mesh->S.size());

    OptixMaterials selectSet;
    selectSet.reserve (mesh->S.size());

    for (auto& S : mesh->S)
    {
        uint32_t matIndex = state->materialID++;

        sabi::Material& m = S.getMaterial();
        m.setIndex (matIndex);

        // surface material
        optixu::Material surfaceMat = state->context.createMaterial();
        surfaceMat.setHitGroup (state->engine.getSearchRayType(), state->engine.getShadingHitGroup());
        if (state->engine.getPipelineType() == RenderMode::PathTracer)
            surfaceMat.setHitGroup (state->engine.getVisibilityRayType(), state->engine.getVisiblityHitGroup());

        Shared::MaterialData surfaceData = {};
        surfaceData.albedo = make_float3 (sRGB_degamma_s (m.base_color.x()), sRGB_degamma_s (m.base_color.y()), sRGB_degamma_s (m.base_color.z()));
        if (node->getName() == DEFAULT_AREA_LIGHT_NAME)
            surfaceData.isEmitter = true;

        surfaceMat.setUserData (surfaceData);
        surfaceSet.push_back (surfaceMat);

        // selected material
        optixu::Material selectionMat = state->context.createMaterial();
        selectionMat.setHitGroup (state->engine.getSearchRayType(), state->engine.getShadingHitGroup());
        if (state->engine.getPipelineType() == RenderMode::PathTracer)
            selectionMat.setHitGroup (state->engine.getVisibilityRayType(), state->engine.getVisiblityHitGroup());

        Shared::MaterialData selectionData = {};
        // selection color is orange
        selectionData.albedo = make_float3 (sRGB_degamma_s (1.0f), sRGB_degamma_s (0.5f), sRGB_degamma_s (0.0f));
        selectionMat.setUserData (selectionData);
        selectSet.push_back (selectionMat);
    }

    sets.push_back (surfaceSet);
    sets.push_back (selectSet);

    // add 100 random variations
    for (int i = 0; i < 100; i++)
    {
        OptixMaterials random;
        addRandomMaterialSet (random, mesh->S);
        sets.push_back (random);
    }

    materialMap.insert (std::make_pair (node, sets));
}

uint32_t MaterialHandler::addRenderableMaterials (GeometryInstanceRef& geomInst, RenderableNode& node)
{
    createOptixMaterials (node);

    const MaterialHandler::MaterialSets& matSets = getMaterialSets (node);
    jassert (matSets.size());
    uint32_t materialCount = matSets[0].size();

    auto mesh = node->getMesh();
    uint32_t triangleCount = mesh->triangleCount();

    MaterialIndexBufferRef matIndexBuffer = std::make_shared<MaterialIndexBuffer>();

    matIndices.clear();
    if (materialCount > 1)
    {
        matIndices.reserve (triangleCount);

        uint32_t materialIndex = 0;
        for (auto& S : mesh->S)
        {
            uint32_t triCount = S.triangleCount();
            for (int i = 0; i < triCount; i++)
                matIndices.push_back (materialIndex);

            ++materialIndex;
        }

        matIndexBuffer->initialize (state->cuContext, cudau::BufferType::Device, matIndices);
        geomInst->optixGeomInst.setNumMaterials (materialCount, matIndexBuffer.get(), sizeof (uint32_t));

        matIndxBuffers.push_back (matIndexBuffer);
    }
    else
    {
        geomInst->optixGeomInst.setNumMaterials (1, nullptr);
    }

    uint32_t i = 0;
    for (const auto& set : matSets)
    {
        uint32_t j = 0;
        for (const auto& mat : set)
        {
            geomInst->optixGeomInst.setMaterial (i, j, mat);
            geomInst->optixGeomInst.setGeometryFlags (j, OPTIX_GEOMETRY_FLAG_NONE);
            ++j;
        }

        ++i;
    }

    return matSets.size();
}

void MaterialHandler::addRandomMaterialSet (OptixMaterials& matSet, const Surfaces& surfs)
{
    matSet.reserve (surfs.size());

    for (const auto& s : surfs)
    {
        const sabi::Material& m = s.getMaterial();

        optixu::Material mat = state->context.createMaterial();
        mat.setHitGroup (state->engine.getSearchRayType(), state->engine.getShadingHitGroup());
        if (state->engine.getPipelineType() == RenderMode::PathTracer)
            mat.setHitGroup (state->engine.getVisibilityRayType(), state->engine.getVisiblityHitGroup());

        Shared::MaterialData matData = {};
        auto r1 = RandoM::get<RandoM::common> (1, 0.f);
        auto r2 = RandoM::get<RandoM::common> (1, 0.f);
        auto r3 = RandoM::get<RandoM::common> (1, 0.f);

        matData.albedo = make_float3 (sRGB_degamma_s (m.base_color.x() * r1), sRGB_degamma_s (m.base_color.y() * r2), sRGB_degamma_s (m.base_color.z() * r3));
        mat.setUserData (matData);
        matSet.push_back (mat);
    }
}
