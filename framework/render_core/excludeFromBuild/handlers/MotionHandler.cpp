
// This source file was auto-generated by ClassMate++
// Created: 9 Aug 2020 3:08:12 pm
// Copyright (c) 2020, HurleyWorks

// much of this code comes from https://github.com/shocker-0x15/OptiX7_Utility

void MotionHandler::initialize (MoojiStateRef& state)
{
    this->state = state;
}

void MotionHandler::createMotionKeys (RenderableNode& node, InstanceRef& inst)
{
    // need a copies here because the phyics engine may be concurrently modifying
    const SpaceTime st = node->getSpaceTime();

    MatrixRowMajor34f t1;
    getWorldTransform (t1, node->getSpaceTime().previousWorldTransform, node->getSpaceTime().previousScale);

    MatrixRowMajor34f t2;
    getWorldTransform (t2, node->getSpaceTime().worldTransform, node->getSpaceTime().scale);

    TransforM tr;

    TransforM::Mat m0;
    std::memcpy (&m0, t1.data(), sizeof (float) * 12);
    tr.srts.push_back (m0);

    TransforM::Mat m1;
    std::memcpy (&m1, t2.data(), sizeof (float) * 12);
    tr.srts.push_back (m1);

    numMotionKeys = tr.srts.size();

    size_t trMemSize;
    tr.optixTransform = state->scene.createTransform();
    tr.optixTransform.setConfiguration (optixu::TransformType::MatrixMotion, numMotionKeys, &trMemSize);
    tr.optixTransform.setMotionOptions (0.0f, 1.0f, OPTIX_MOTION_FLAG_NONE);
    tr.optixTransform.setChild (inst->geomGroup->optixGAS);
    for (int keyIdx = 0; keyIdx < tr.srts.size(); ++keyIdx)
        tr.optixTransform.setMatrixMotionKey (keyIdx, reinterpret_cast<float*> (&tr.srts[keyIdx].transform));

    tr.deviceMem = new cudau::Buffer;
    tr.deviceMem->initialize (state->engine.cuCtx(), cudau::BufferType::Device, trMemSize, 1);
    tr.optixTransform.rebuild (state->engine.getStream (state->bufferIndex), *tr.deviceMem);
    transformsObject.push_back (tr);

    inst->optixInst.setChild (tr.optixTransform);

    Vector3f min = st.modelBound.min();
    Vector3f max = st.modelBound.max();

    AABB aabb;
    aabb.minP = make_float3 (min.x(), min.y(), min.z());
    aabb.maxP = make_float3 (max.x(), max.y(), max.z());
    baseAABBsObject.push_back (aabb);
}

void MotionHandler::computeMotionAABBs()
{
    jassert (state->groups.size());

    OptixAabb* aabbs = state->groups[0]->aabbBuffer.map();

    for (int instIdx = 0; instIdx < transformsObject.size(); ++instIdx)
    {
        RenderableNode node = nullptr;

        const TransforM& tr = transformsObject[instIdx];
        const AABB& baseAABB = baseAABBsObject[instIdx];
        auto it = state->weakNodes.find (instIdx);
        if (it != state->weakNodes.end())
            node = it->second.lock();

        LOG (DBUG) << "====================  " << node->getName();
        for (int keyIdx = 0; keyIdx < numMotionKeys; ++keyIdx)
        {
            OptixAabb& aabb = aabbs[instIdx * numMotionKeys + keyIdx];

            const TransforM::Mat& m = tr.srts[keyIdx];
            MatrixRowMajor34f tmp;

            std::memcpy (tmp.data(), &m, sizeof (float) * 12);

            Vector3f p = tmp.col (3);
            //vecStr3f(p, DBUG, "BLUR POS");
            Matrix3f o = tmp.block<3, 3> (0, 0);

            Matrix3x3 sr (o.data());
            float3 trans = make_float3 (p.x(), p.y(), p.z());

            float3 c;
            AABB trBBox;

            c = sr * float3 (baseAABB.minP.x, baseAABB.minP.y, baseAABB.minP.z) + trans;
            trBBox.unify (c);
            c = sr * float3 (baseAABB.maxP.x, baseAABB.minP.y, baseAABB.minP.z) + trans;
            trBBox.unify (c);
            c = sr * float3 (baseAABB.minP.x, baseAABB.maxP.y, baseAABB.minP.z) + trans;
            trBBox.unify (c);
            c = sr * float3 (baseAABB.maxP.x, baseAABB.maxP.y, baseAABB.minP.z) + trans;
            trBBox.unify (c);
            c = sr * float3 (baseAABB.minP.x, baseAABB.minP.y, baseAABB.maxP.z) + trans;
            trBBox.unify (c);
            c = sr * float3 (baseAABB.maxP.x, baseAABB.minP.y, baseAABB.maxP.z) + trans;
            trBBox.unify (c);
            c = sr * float3 (baseAABB.minP.x, baseAABB.maxP.y, baseAABB.maxP.z) + trans;
            trBBox.unify (c);
            c = sr * float3 (baseAABB.maxP.x, baseAABB.maxP.y, baseAABB.maxP.z) + trans;
            trBBox.unify (c);

            // EN: It is fairly complex to compute a tight AABB which contains all trajectories of vertices
            //     between keyframes when rotation is involved.
            //     Simply dilate the AABB of each key by 2 for simplicity here.
            // trBBox.dilate (2.0f);

            aabb.minX = trBBox.minP.x;
            aabb.minY = trBBox.minP.y;
            aabb.minZ = trBBox.minP.z;
            aabb.maxX = trBBox.maxP.x;
            aabb.maxY = trBBox.maxP.y;
            aabb.maxZ = trBBox.maxP.z;

            LOG (DBUG) << "MIN " << aabb.minX << ", " << aabb.minY << ", " << aabb.minZ;
            LOG (DBUG) << "MAX " << aabb.maxX << ", " << aabb.maxY << ", " << aabb.maxZ;
        }
    }

    state->groups[0]->aabbBuffer.unmap();
}

void MotionHandler::updateMotionAABBs()
{
    if (!transformsObject.size()) return;

    int index = 0;
    for (auto& it : state->weakNodes)
    {
        RenderableNode& node = it.second.lock();

        // need a copies here because the phyics engine may be concurrently modifying
        const SpaceTime st = node->getSpaceTime();

        MatrixRowMajor34f t1;
        getWorldTransform (t1, node->getSpaceTime().previousWorldTransform, node->getSpaceTime().previousScale);

        MatrixRowMajor34f t2;
        getWorldTransform (t2, node->getSpaceTime().worldTransform, node->getSpaceTime().scale);

        TransforM& tr = transformsObject[index];
        tr.srts.clear();

        TransforM::Mat m0;
        std::memcpy (&m0, t1.data(), sizeof (float) * 12);
        tr.srts.push_back (m0);

        TransforM::Mat m1;
        std::memcpy (&m1, t2.data(), sizeof (float) * 12);
        tr.srts.push_back (m1);

        for (int keyIdx = 0; keyIdx < tr.srts.size(); ++keyIdx)
            tr.optixTransform.setMatrixMotionKey (keyIdx, reinterpret_cast<float*> (&tr.srts[keyIdx].transform));

        tr.optixTransform.rebuild (state->engine.getStream (state->bufferIndex), *tr.deviceMem);

        Vector3f min = st.modelBound.min();
        Vector3f max = st.modelBound.max();

        AABB& aabb = baseAABBsObject[index];
        aabb.minP = make_float3 (min.x(), min.y(), min.z());
        aabb.maxP = make_float3 (max.x(), max.y(), max.z());

        ++index;
    }
}

void MotionHandler::updateMotion()
{
    for (const auto& it : state->weakNodes)
    {
        uint32_t intanceID = it.first;
        RenderableNode& node = it.second.lock();
        if (!node) continue;

        auto itr = state->insts.find (intanceID);
        if (itr == state->insts.end()) continue;

        InstanceRef& inst = itr->second;

        // OptixInstance wants a affine object-to-world transformation
        // as 3x4 matrix in row-major layout
        MatrixRowMajor34f t;
        getWorldTransform (t, node->getSpaceTime().worldTransform, node->getSpaceTime().scale);
        inst->optixInst.setTransform (t.data());
    }
}