// This source file was auto-generated by ClassMate++
// Created: 8 Sep 2020 8:44:40 pm
// Copyright (c) 2020, HurleyWorks

using Eigen::Vector2f;
using Eigen::Vector3f;
using sabi::SpaceTime;

// ctor
MeshHandler::MeshHandler (OptiXStateRef state) :
    state (state)
{
}

// dtor
MeshHandler::~MeshHandler()
{
}

void MeshHandler::onSelectionStateChanged (RenderableNode& node)
{
    Instance* const inst = static_cast<Instance*> (node->getUserdata2());
    if (!inst) return;

    uint32_t geoGroupID = node->isInstance() ? node->getInstancedFrom()->getClientID() : node->getClientID();
    const GeometryGroupRef& geomGroup = state->geomGroups.at (geoGroupID);

    // material set 1 is the selection material (orange)
    inst->optixInst.setChild (geomGroup->optixGAS, node->getState().isSelected() ? 1 : 0);
}

GeometryInstanceRef MeshHandler::addRenderableGeometry (RenderableNode& node)
{
    auto mesh = node->getMesh();

    OptixVertices vertices;
    uint32_t vertexCount = addVertices (mesh, vertices);
    if (!vertexCount)
        throw std::runtime_error ("No vertices found: " + node->getName());

    OptixTriangles triangles;
    uint32_t triangleCount = addAllTriangles (mesh, triangles);
    if (!triangleCount)
        throw std::runtime_error ("No triangles found: " + node->getName());

    VertexBufferRef vertexBuffer = make_shared_with_deleter<cudau::TypedBuffer<Shared::Vertex>> (
        [] (cudau::TypedBuffer<Shared::Vertex>* p) {
            p->finalize();
        });
    vertexBuffer->initialize (state->cuContext, g_bufferType, vertices);

    GeometryInstanceRef geomInst = make_shared_with_deleter<GeometryInstance> (GeometryInstance::finalize);

    uint32_t serialID = state->geomInstSerialID++;
    geomInst->optixEnv = state.get();
    geomInst->serialID = serialID;
    geomInst->name = node->getName();
    geomInst->vertexBuffer = vertexBuffer;
    geomInst->triangleBuffer.initialize (state->cuContext, g_bufferType, triangles, state->cuStream);
    geomInst->optixGeomInst = state->scene.createGeometryInstance();
    geomInst->optixGeomInst.setVertexBuffer (getView (*vertexBuffer));
    geomInst->optixGeomInst.setTriangleBuffer (getView (geomInst->triangleBuffer));

    Shared::GeometryData geomData = {};
    geomData.vertexBuffer = vertexBuffer->getDevicePointer();
    geomData.triangleBuffer = geomInst->triangleBuffer.getDevicePointer();
    geomInst->optixGeomInst.setUserData (geomData);

    state->geomInsts[serialID] = geomInst;

    return geomInst;
}

GeometryGroupRef MeshHandler::createGeometryGroup (RenderableNode& node, uint32_t materialSetCount, GeometryInstanceRef geomInst, PipelineHandlerRef& pipeline)
{
    uint32_t serialID = state->gasSerialID++;

    // FIXME clientID is used in LW so maybe add a new ID  type  to Renderable
    node->setClientID (serialID);

    GeometryGroupRef geomGroup = make_shared_with_deleter<GeometryGroup> (GeometryGroup::finalize);
    char name[256];
    sprintf_s (name, "GAS-%u", serialID);
    geomGroup->optixEnv = state.get();
    geomGroup->serialID = serialID;
    geomGroup->name = name;
    geomGroup->optixGAS = state->scene.createGeometryAccelerationStructure();
    geomGroup->optixGAS.setConfiguration (optixu::ASTradeoff::PreferFastTrace, false, true, false);

    geomGroup->optixGAS.setNumMaterialSets (materialSetCount);
    for (int matSetIdx = 0; matSetIdx < materialSetCount; ++matSetIdx)
        geomGroup->optixGAS.setNumRayTypes (matSetIdx, pipeline->getRayTypeCount());

    geomGroup->geomInsts.push_back (geomInst);
    geomGroup->optixGAS.addChild (geomInst->optixGeomInst);

    state->geomGroups[serialID] = geomGroup;

    return geomGroup;
}

InstanceRef MeshHandler::createInstance (RenderableNode& node, GeometryGroupRef& geomGroup)
{
    bool isInstance = node->isInstance();

    const SpaceTime& st = node->getSpaceTime();
    const Vector3f& pos = st.worldTransform.translation();
    const Vector3f& scale = st.scale;

    // OptixInstance wants a affine object-to-world transformation
    // as 3x4 matrix in row-major layout
    MatrixRowMajor34f t;
    getWorldTransform (t, node->getSpaceTime().worldTransform, node->getSpaceTime().scale);

    uint32_t serialID = state->instSerialID++;

    InstanceRef inst = make_shared_with_deleter<Instance> (Instance::finalize);
    inst->optixEnv = state.get();
    inst->serialID = serialID;
    inst->name = node->getName();
    inst->weakNode = node;
    inst->optixInst = state->scene.createInstance();
    inst->scale = float3 (scale.x(), scale.y(), scale.z());
    inst->position = float3 (pos.x(), pos.y(), pos.z());

    auto randomMaterialSet = RandoM::get<uint8_t> (RANDOM_MATERIAL_COUNT, 2);
    inst->optixInst.setChild (geomGroup->optixGAS, isInstance ? randomMaterialSet : 0);
   
    inst->geomGroup = geomGroup;
    geomGroup->parentInsts.insert (inst);

    node->setUserData2 (inst.get());

    inst->optixInst.setTransform (t.data());
    state->insts[serialID] = inst;
    return inst;
}

uint32_t MeshHandler::addVertices (MeshBuffersHandle& mesh, OptixVertices& vertices)
{
    uint32_t vertexCount = mesh->V.cols();

    if (!vertexCount)
        return 0;

    vertices.reserve (vertexCount);

    for (int i = 0; i < vertexCount; i++)
    {
        Shared::Vertex v;

        Vector3f p = mesh->V.col (i);
        Vector3f n = mesh->N.col (i);

        // mace::vecStr3f (n, DBUG, "NORMAL");

        v.position.x = p.x();
        v.position.y = p.y();
        v.position.z = p.z();

        v.normal.x = n.x();
        v.normal.y = n.y();
        v.normal.z = n.z();

        v.texCoord.x = 0;
        v.texCoord.y = 0;

        vertices.push_back (v);
    }

    return vertexCount;
}

uint32_t MeshHandler::addAllTriangles (MeshBuffersHandle& mesh, OptixTriangles& triangles)
{
    MatrixXu tris;
    mesh->getAllSurfaceIndices (tris);
    triangles.reserve (tris.cols());

    for (int i = 0; i < tris.cols(); i++)
    {
        Vector3u tri = tris.col (i);

        Shared::Triangle t;
        t.index0 = tri.x();
        t.index1 = tri.y();
        t.index2 = tri.z();

        triangles.push_back (t);
    }

    return tris.cols();
}
