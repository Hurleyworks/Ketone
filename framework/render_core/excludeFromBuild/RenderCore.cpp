// This source file was auto-generated by ClassMate++
// Created: 28 Feb 2018 8:30:14 am
// Copyright (c) 2018, HurleyWorks

using sabi::InputEvent;

// init
void RenderCore::init (MessageService messenger, const PropertyService& properties)
{
    this->messengers = messengers;
    this->properties = properties;

    compiler.compile(properties);
}

void RenderCore::initEngine (CameraHandle& camera)
{
    ptxFolder = properties.renderProps->getVal<std::string> (RenderKey::PtxFolder);
    enableMotionBlur = properties.renderProps->getVal<bool> (RenderKey::MotionBlur);
    pipelineType = RenderMode::PathTracer;

    state = OptiXEnv::create();
    state->engine.initialize();
    state->engine.setPipeline (ptxFolder, pipelineType, enableMotionBlur);
    state->initialize (state->engine.cuCtx(), state->engine.optCtx());

    scene = SceneHandler::create();
    scene->initialize (state);

    switch (pipelineType)
    {
        case RenderMode::PathTracer:
            renderer = PathTracer::create (properties);
            break;

        default:

            break;
    }

    renderer->initialize (state, camera);
    renderer->initializeLaunchParameters (camera);

    mesh = MeshHandler::create();
    mesh->initialize (state);
}

void RenderCore::render (CameraHandle& camera, uint32_t frameNumber)
{
    bool reset = false;

    size_t currentSelectedCount = state->selected.size();
    if (lastSelectedCount != currentSelectedCount)
    {
        for (const auto& it : state->selected)
            mesh->onSelectionStateChanged (it.second.lock());

        for (const auto& it : state->deselected)
            mesh->onSelectionStateChanged (it.second.lock());

        state->deselected.clear();

        lastSelectedCount = currentSelectedCount;

        scene->stateHasChanged (true);
        reset = true;
    }

    if (camera->isDirty())
    {
        renderer->updateCamera (camera);
        reset = true;
        camera->setDirty (false);
    }

    if (sceneIsDirty)
    {
        reset = true;
        sceneIsDirty = false;
    }

    float renderTime = renderer->render (camera, input, frameNumber, reset);
    properties.renderProps->setValue (RenderKey::RenderTime, static_cast<double> (renderTime * 0.001f));
}

void RenderCore::onInput (InputEvent& input)
{
    this->input = input;

    // If we're in Camera mode, picking is enabled with RMB press or drag
    if (input.getButton() == InputEvent::Right && (input.getType() == InputEvent::Press || input.getType() == InputEvent::Drag))
    {
        renderer->generatePickRay (input.getX(), input.getY());
    }
}
