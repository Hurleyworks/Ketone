// This header file was auto-generated by ClassMate++
// Created: 16 Jul 2020 9:21:09 pm
// Copyright (c) 2020, HurleyWorks

// much of this code comes from https://github.com/shocker-0x15/OptiX7_Utility
// scene_edit sample

#pragma once

constexpr cudau::BufferType g_bufferType = cudau::BufferType::Device;

constexpr uint32_t MaxNumInstances = 512;
constexpr uint32_t MaxNumGeometryInstances = 8192;
constexpr uint32_t MaxNumGASs = 512;

using Eigen::Vector3f;
using sabi::RenderableNode;
using sabi::RenderableWeakRef;
using sabi::WeakRenderableMap;

struct OptiXEnv;

using VertexBufferRef = std::shared_ptr<cudau::TypedBuffer<Shared::Vertex>>;
using GeometryInstanceRef = std::shared_ptr<struct GeometryInstance>;
using GeometryInstanceWRef = std::weak_ptr<struct GeometryInstance>;
using GeometryGroupRef = std::shared_ptr<struct GeometryGroup>;
using GeometryGroupWRef = std::weak_ptr<struct GeometryGroup>;
using InstanceRef = std::shared_ptr<struct Instance>;
using InstanceWRef = std::weak_ptr<struct Instance>;
using GroupRef = std::shared_ptr<struct Group>;
using GroupWRef = std::weak_ptr<struct Group>;
using MoojiStateRef = std::shared_ptr<struct OptiXEnv>;
using SelectedMap = std::unordered_map<InstanceRef, RenderableWeakRef>;

struct GeometryInstance
{
    OptiXEnv* optixEnv;
    uint32_t geomInstIndex;
    uint32_t serialID;
    std::string name;
    optixu::GeometryInstance optixGeomInst;
    VertexBufferRef vertexBuffer;
    cudau::TypedBuffer<Shared::Triangle> triangleBuffer;
    bool dataTransfered = false;

    static void finalize (GeometryInstance* p);
};

struct GeometryGroup
{
    OptiXEnv* optixEnv;
    uint32_t gasIndex;
    uint32_t serialID;
    std::string name;
    optixu::GeometryAccelerationStructure optixGAS;
    std::vector<GeometryInstanceRef> geomInsts;
    std::vector<Shared::GeometryInstancePreTransform> preTransforms;
    cudau::TypedBuffer<Shared::GeometryInstancePreTransform> preTransformBuffer;
    std::set<InstanceWRef, std::owner_less<InstanceWRef>> parentInsts;
    cudau::Buffer optixGasMem;
    bool dataTransfered = false;

    static void finalize (GeometryGroup* p);
};

struct Instance
{
    OptiXEnv* optixEnv;
    uint32_t serialID;
    std::string name;
    optixu::Instance optixInst;
    GeometryGroupRef geomGroup;
    std::set<GroupWRef, std::owner_less<GroupWRef>> parentGroups;
    float3 scale;
    float rollPitchYaw[3];
    float3 position;
    RenderableNode node = nullptr;
    static void finalize (Instance* p);
};

struct Group
{
    OptiXEnv* optixEnv;
    uint32_t serialID;
    std::string name;
    optixu::InstanceAccelerationStructure optixIAS;
    std::vector<InstanceRef> insts;
    cudau::Buffer optixIasMem;
    cudau::TypedBuffer<OptixInstance> optixInstanceBuffer;
    cudau::TypedBuffer<OptixAabb> aabbBuffer;

    static void finalize (Group* p);
};

struct OptiXEnv
{
    static MoojiStateRef create() { return std::make_shared<OptiXEnv>(); }

    ~OptiXEnv()
    {
    }
    void initialize (CUcontext& cuCtx, optixu::Context& optCtx)
    {
        cuContext = cuCtx;
        context = optCtx;
        scene = context.createScene();
        geometryDataBuffer.initialize (cuContext, g_bufferType, MaxNumGeometryInstances);
        pickDataBuffer.initialize (cuContext, g_bufferType, 1);
        geometryInstSlotFinder.initialize (MaxNumGeometryInstances);
        gasDataBuffer.initialize (cuContext, g_bufferType, MaxNumGASs);
        gasSlotFinder.initialize (MaxNumGASs);
        geomInstSerialID = 0;
        gasSerialID = 0;
        instSerialID = 0;
        iasSerialID = 0;
        asScratchBuffer.initialize (cuContext, g_bufferType, 32 * 1024 * 1024, 1);
    }

    void reset (bool clearRenderables = true)
    {
        geomGroups.clear();
        geomInsts.clear();
        insts.clear();
        groups.clear();
        if (clearRenderables)
            weakNodes.clear();

        geomInstSerialID = 0;
        gasSerialID = 0;
        instSerialID = 0;
        iasSerialID = 0;
        materialID = 0;

        uint32_t bufferIndex = 0;
        uint32_t sbtIndex = 0;
    }

    CUcontext cuContext;
    optixu::Context context;
    PipelineHandler engine;
    optixu::Scene scene;
    cudau::TypedBuffer<Shared::GeometryData> geometryDataBuffer;
    SlotFinder geometryInstSlotFinder;
    cudau::TypedBuffer<Shared::GASData> gasDataBuffer;
    SlotFinder gasSlotFinder;
    cudau::TypedBuffer<Shared::MaterialData> materialDataBuffer;
    cudau::TypedBuffer<Shared::PickingData> pickDataBuffer;

    uint32_t geomInstSerialID = 0;
    uint32_t gasSerialID = 0;
    uint32_t instSerialID = 0;
    uint32_t iasSerialID = 0;
    uint32_t materialID = 0;

    // FIXME
    uint32_t areaLightIndex = 0;

    std::map<uint32_t, GeometryInstanceRef> geomInsts;
    std::map<uint32_t, GeometryGroupRef> geomGroups;
    std::map<uint32_t, InstanceRef> insts;
    std::map<uint32_t, GroupRef> groups;

    cudau::Buffer asScratchBuffer;
    cudau::Buffer hitGroupSBT;
  
    WeakRenderableMap weakNodes;
    SelectedMap selected;
    SelectedMap deselected;
};

void GeometryInstance::finalize (GeometryInstance* p)
{
    p->optixGeomInst.destroy();
    p->triangleBuffer.finalize();
    p->optixEnv->geometryInstSlotFinder.setNotInUse (p->geomInstIndex);
    delete p;
}

void GeometryGroup::finalize (GeometryGroup* p)
{
    p->optixGasMem.finalize();
    p->preTransformBuffer.finalize();
    p->optixGAS.destroy();
    p->optixEnv->gasSlotFinder.setNotInUse (p->gasIndex);
    delete p;
}

void Instance::finalize (Instance* p)
{
    p->optixInst.destroy();
    delete p;
}

void Group::finalize (Group* p)
{
    p->optixInstanceBuffer.finalize();
    p->optixIasMem.finalize();
    p->optixIAS.destroy();
    delete p;
}

struct Transform
{
    struct SRT
    {
        float3 s;
        Quaternion o;
        float3 t;
    };
    std::vector<SRT> srts;
    optixu::Transform optixTransform;
    cudau::Buffer* deviceMem;
};

struct TransforM
{
    struct Mat
    {
        float transform[12];
    };
    std::vector<Mat> srts;
    optixu::Transform optixTransform;
    cudau::Buffer* deviceMem;
};

struct GPUTimer
{
    cudau::Timer frame;
    cudau::Timer deform;
    cudau::Timer updateGAS;
    cudau::Timer updateIAS;
    cudau::Timer render;
    cudau::Timer postProcess;
    bool animated;

    void initialize (CUcontext context)
    {
        frame.initialize (context);
        deform.initialize (context);
        updateGAS.initialize (context);
        updateIAS.initialize (context);
        render.initialize (context);
        postProcess.initialize (context);
        animated = false;
    }
    void finalize()
    {
        postProcess.finalize();
        render.finalize();
        updateIAS.finalize();
        updateGAS.finalize();
        deform.finalize();
        frame.finalize();
    }
};

inline void getWorldTransform (MatrixRowMajor34f& t, Eigen::Affine3f& xform, Vector3f& scale)
{
    // apply the scale to the basis vectors
    // of the orientation just like LW
    sabi::Affine3f scaled = xform;
    for (int j = 0; j < 3; j++)
        scaled.linear().col (j) *= scale[j];

    Matrix4f m = scaled.matrix();

    // OptixInstance wants a affine object-to-world transformation
    // as 3x4 matrix in row-major layout
    // pull out a 3 x 4 sub matrix
    t = m.block<3, 4> (0, 0);
}
