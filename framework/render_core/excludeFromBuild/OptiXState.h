// This header file was auto-generated by ClassMate++
// Created: 7 Sep 2020 8:08:36 pm
// Copyright (c) 2020, HurleyWorks

#pragma once

using Eigen::Vector3f;
using sabi::Affine3f;
using sabi::RenderableNode;
using sabi::RenderableWeakRef;

const uint32_t RANDOM_MATERIAL_COUNT = 25;

struct OptiXEnv;

constexpr cudau::BufferType g_bufferType = cudau::BufferType::Device;
using VertexBufferRef = std::shared_ptr<cudau::TypedBuffer<Shared::Vertex>>;

using GeometryInstanceRef = std::shared_ptr<struct GeometryInstance>;
using GeometryInstanceWRef = std::weak_ptr<struct GeometryInstance>;
using GeometryGroupRef = std::shared_ptr<struct GeometryGroup>;
using GeometryGroupWRef = std::weak_ptr<struct GeometryGroup>;
using InstanceRef = std::shared_ptr<struct Instance>;
using InstanceWRef = std::weak_ptr<struct Instance>;
using GroupRef = std::shared_ptr<struct Group>;
using GroupWRef = std::weak_ptr<struct Group>;

using OptiXStateRef = std::shared_ptr<struct OptiXEnv>;

struct GeometryInstance
{
    OptiXEnv* optixEnv = nullptr;
    uint32_t serialID = ~0;
    std::string name = INVALID_NAME;
    optixu::GeometryInstance optixGeomInst;
    VertexBufferRef vertexBuffer = nullptr;
    cudau::TypedBuffer<Shared::Triangle> triangleBuffer;

    GeometryInstance() {}
    static void finalize (GeometryInstance* p);
};

struct GeometryGroup
{
    OptiXEnv* optixEnv = nullptr;
    uint32_t serialID = ~0;
    std::string name = INVALID_NAME;
    optixu::GeometryAccelerationStructure optixGAS;
    std::vector<GeometryInstanceRef> geomInsts;

    std::set<InstanceWRef, std::owner_less<InstanceWRef>> parentInsts;
    cudau::Buffer optixGasMem;

    GeometryGroup() {}
    static void finalize (GeometryGroup* p);

    void propagateMarkDirty() const;
};

struct Instance
{
    OptiXEnv* optixEnv = nullptr;
    uint32_t serialID = ~0;
    std::string name = INVALID_NAME;
    optixu::Instance optixInst;
    RenderableWeakRef weakNode;
    GeometryGroupRef geomGroup = nullptr;
    GroupRef group = nullptr;
    std::set<GroupWRef, std::owner_less<GroupWRef>> parentGroups;
    float3 scale = make_float3 (1.0f);
    float rollPitchYaw[3] = {0.0f, 0.0f, 0.0f};
    float3 position = make_float3 (0.0f);
    
    static void finalize (Instance* p);

    void propagateMarkDirty() const;
};

struct Group
{
    OptiXEnv* optixEnv = nullptr;
    uint32_t serialID = ~0;
    std::string name = INVALID_NAME;
    optixu::InstanceAccelerationStructure optixIAS;
    std::vector<InstanceRef> insts;
    std::set<InstanceWRef, std::owner_less<InstanceWRef>> parentInsts;
    cudau::Buffer optixIasMem;
    cudau::TypedBuffer<OptixInstance> optixInstanceBuffer;

    static void finalize (Group* p);

    void propagateMarkDirty() const;
};

struct OptiXEnv
{
    static OptiXStateRef create() { return std::make_shared<OptiXEnv>(); }

    OptiXEnv()
    {
        initialize();
    }

    ~OptiXEnv()
    {
        finalize();
    }

    int32_t cuDeviceCount = -1;
    CUcontext cuContext;
    optixu::Context optixContext;
    CUstream cuStream = nullptr;
    optixu::Scene scene;

    uint32_t geomInstSerialID = 0;
    uint32_t gasSerialID = 0;
    uint32_t instSerialID = 0;
    uint32_t iasSerialID = 0;
    uint32_t materialID = 0;

    std::map<uint32_t, GroupRef> groups;
    std::map<uint32_t, GeometryGroupRef> geomGroups;
    std::map<uint32_t, InstanceRef> insts;
    std::unordered_map<uint32_t, GeometryInstanceRef> geomInsts;

    cudau::Buffer asScratchBuffer;
    cudau::Buffer hitGroupSBT[2]; // double buffer

 private:
    void initialize()
    {
        CUDADRV_CHECK (cuInit (0));
        CUDADRV_CHECK (cuDeviceGetCount (&cuDeviceCount));
        CUDADRV_CHECK (cuCtxCreate (&cuContext, 0, 0));
        CUDADRV_CHECK (cuCtxSetCurrent (cuContext));
        CUDADRV_CHECK (cuStreamCreate (&cuStream, 0));

        optixContext = optixu::Context::create (cuContext);
        scene = optixContext.createScene();
        asScratchBuffer.initialize (cuContext, g_bufferType, 32 * 1024 * 1024, 1);
    }
    void finalize()
    {
        groups.clear();
        insts.clear();
        geomInsts.clear();
        geomGroups.clear();

        hitGroupSBT[1].finalize();
        hitGroupSBT[0].finalize();
        asScratchBuffer.finalize();
        scene.destroy();
        optixContext.destroy();

        CUDADRV_CHECK (cuStreamDestroy (cuStream));
        CUDADRV_CHECK (cuCtxDestroy (cuContext));
    }
};

inline void getWorldTransform (MatrixRowMajor34f& t, Affine3f& xform, Vector3f& scale)
{
    // apply the scale to the basis vectors
    // of the orientation just like LW
    sabi::Affine3f scaled = xform;
    for (int j = 0; j < 3; j++)
        scaled.linear().col (j) *= scale[j];

    Matrix4f m = scaled.matrix();

    // OptixInstance wants a affine object-to-world transformation
    // as 3x4 matrix in row-major layout
    // pull out a 3 x 4 sub matrix
    t = m.block<3, 4> (0, 0);
}

struct GPUTimer
{
    cudau::Timer frame;
    cudau::Timer deform;
    cudau::Timer updateGAS;
    cudau::Timer updateIAS;
    cudau::Timer render;
    cudau::Timer postProcess;
    bool animated;

    void initialize (CUcontext context)
    {
        frame.initialize (context);
        deform.initialize (context);
        updateGAS.initialize (context);
        updateIAS.initialize (context);
        render.initialize (context);
        postProcess.initialize (context);
        animated = false;
    }
    void finalize()
    {
        postProcess.finalize();
        render.finalize();
        updateIAS.finalize();
        updateGAS.finalize();
        deform.finalize();
        frame.finalize();
    }
};