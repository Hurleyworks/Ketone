// This source file was auto-generated by ClassMate++
// Created: 29 Dec 2018 3:47:40 pm
// Copyright (c) 2018, HurleyWorks

using namespace std::chrono_literals;
using Eigen::AlignedBox3f;
using sabi::NormalizedClump;
using sabi::RenderableList;

// ctor
WorldOps::WorldOps (RenderableNode world) :
    world (world)
{
    loadStrategy = std::make_unique<NormalizedClump>();
}

// dtor
WorldOps::~WorldOps()
{
}

void WorldOps::createInstanceClump (int instanceCount)
{
    // this is designed to work with 1 selection
    RenderableNode selectedNode = nullptr;
    for (auto const it : world->getChildren())
    {
        RenderableNode node = it.second;
        if (node->getState().isSelected())
        {
            selectedNode = node;
            break;
        }
    }

    // if nothing is selected then tell the user he must select 1 object
    if (!selectedNode)
        throw std::runtime_error ("One and only one object must be selected to use this tool");

    bool randomScale = properties.worldProps->getVal<bool> (WorldKey::RandomInstanceScale);

    for (int i = 0; i < instanceCount; ++i)
    {
        RenderableNode instance = selectedNode->createInstance();
        instance->setName (selectedNode->getName() + "_instance_" + std::to_string (i + 1));

        loadStrategy->addNextItem (instance->getSpaceTime());

        if (randomScale)
        {
            // FIXME should be user defined randomness
            auto scale = RandoM::get<RandoM::common> (2.0, 0.5f);
            for ( int i = 0; i < 3; i++)
                instance->getSpaceTime().scale[i] = scale;
        }

        // rest on ground
        AlignedBox3f newBounds = instance->getSpaceTime().modelBound;
        for (int i = 0; i < 3; i++)
        {
            newBounds.min()[i] *= instance->getSpaceTime().scale[i];
            newBounds.max()[i] *= instance->getSpaceTime().scale[i];
        }
        instance->getSpaceTime().worldTransform.translation().y() = -newBounds.min().y();

        world->addChild (instance);

        // send it to the Renderer
        messengers.render.send (QMS::addNodeToRenderer (instance));
    }
}
