// This source file was auto-generated by ClassMate++
// Created: 28 Feb 2018 8:30:14 am
// Copyright (c) 2018, HurleyWorks

using Eigen::AlignedBox3f;
using namespace sabi; //we're using almost all of it anyway
using Eigen::Quaternionf;
using juce::String;

// init
void GeoCore::init (MessageService messengers, const PropertyService& properties)
{
    this->messengers = messengers;
    this->properties = properties;

    loadStrategy = std::make_unique<NormalizedClump>();
}

// tick
void GeoCore::tick (size_t frameNumber)
{
    // Everybody needs a tick or 2
}

void GeoCore::processLoadData (const LoadData&& loadData)
{
    if (loadData.size() > 1)
    {
        // multiple meshes not supported yet
        return;
    }

    for (auto data : loadData)
    {
        processRenderableData (data);
    }
}

void GeoCore::processRenderableData (RenderableData& d)
{
    MeshBuffersHandle& mesh = d.mesh;
    MeshOptions& meshOptions = d.meshOptions;
    SpaceTime& spacetime = d.spacetime;

    // create vertex normals  if they aren't there
    if (!mesh->N.cols())
    {
        MatrixXu allIndices;
        mesh->getAllSurfaceIndices (allIndices);
        MeshOps::generate_smooth_normals (allIndices, mesh->V, mesh->N, false);
    }

    AlignedBox3f modelBound;
    modelBound.min() = mesh->V.rowwise().minCoeff();
    modelBound.max() = mesh->V.rowwise().maxCoeff();
    float scale = 1.0f;

    if (modelBound.isEmpty())
        throw std::runtime_error ("Empty bounding box detected for " + d.name);

    // this might change scale!
    if ((meshOptions & MeshOptions::NormalizeSize) == MeshOptions::NormalizeSize)
        MeshOps::normalizeSize (mesh, modelBound, scale);

    if ((meshOptions & MeshOptions::CenterVertices) == MeshOptions::CenterVertices)
        MeshOps::centerVertices (mesh, modelBound, scale);

    // recalc new modelBound
    modelBound.min() = mesh->V.rowwise().minCoeff();
    modelBound.max() = mesh->V.rowwise().maxCoeff();
    spacetime.modelBound = modelBound;

    if ((meshOptions & MeshOptions::LoadStrategy) == MeshOptions::LoadStrategy)
        loadStrategy->addNextItem (spacetime);

    if ((meshOptions & MeshOptions::RestOnGround) == MeshOptions::RestOnGround)
        spacetime.worldTransform.translation().y() = -spacetime.modelBound.min().y();

    spacetime.startTransform = spacetime.worldTransform;
    spacetime.updateWorldBounds (true);

    // send it to the World!
    messengers.world.send (QMS::createNewRenderable (d));
}

void GeoCore::createGroundPlane (const Vector2f& size)
{
    std::string name = "Default_ground";

    Material material;
    material.base_color = Vector4f (1.0f, 1.0f, 1.0f, 1.0f);
    material.metallic = 0.0f;
    material.roughness = 0.0f;
    material.base_color_tex = nullptr;

    Vector3f pos (0.0f, 0.0f, 0.0f);
    Vector3f dir (0.0f, 1.0f, 0.0f);

    createQuad (size, pos, dir, material, name);
}

void GeoCore::createQuad (const Vector2f& size, const Vector3f& position, const Vector3f& direction, const Material& material, const std::string& name)
{
    MatrixXu F;  // faces
    MatrixXf V;  // vertices
    MatrixXf N;  // vertex normals
    MatrixXf UV; // texture coords

    V.resize (3, 6);
    const Vector3f verts[6] = {{-size.x(), 0.0f, -size.y()}, {size.x(), 0.0f, -size.y()}, {-size.x(), 0.0f, size.y()}, {-size.x(), 0.0f, size.y()}, {size.x(), 0.0f, -size.y()}, {size.x(), 0.0f, size.y()}};
    for (int i = 0; i < 6; i++)
        V.col (i) = verts[i];

    F.resize (3, 2);
    const Vector3u faces[2] = {{2, 1, 0}, {5, 4, 3}};
    for (int i = 0; i < 2; i++)
        F.col (i) = faces[i];

    N.resize (3, 6);
    for (int i = 0; i < 6; i++)
    {
        if (name == DEFAULT_AREA_LIGHT_NAME)
            N.col (i) = -Vector3f::UnitY();
        else
            N.col (i) = Vector3f::UnitY();
    }

    UV.resize (2, 6);
    const Vector2f texcoords[6] = {{0, 0}, {1, 0}, {0, 1}, {0, 1}, {1, 0}, {1, 1}};
    for (int i = 0; i < 6; i++)
        UV.col (i) = texcoords[i];

    VertexMapRef vmap = VertexMap::create();
    vmap->dim = 2;
    vmap->type = VertexMapType::UV;
    vmap->values = UV;

    // create the new pose
    Pose pose;
    pose.setIdentity();
    pose.translation() = position;

    // Returns a quaternion representing a rotation between the two arbitrary vectors a and b.
    // In other words, the built rotation represent a rotation sending the line of direction a
    // to the line of direction b, both lines passing through the origin.
    Quaternionf q;
    Quaternionf r = q.FromTwoVectors (Vector3f::UnitY(), direction);
    //if (name != DEFAULT_AREA_LIGHT_NAME)
    // pose.rotate (r);

    SpaceTime spacetime;
    spacetime.modelBound.min() = V.rowwise().minCoeff();
    spacetime.modelBound.max() = V.rowwise().maxCoeff();
    spacetime.worldTransform = pose;
    spacetime.startTransform = spacetime.worldTransform;
    spacetime.scale = Scale::Constant (1.0f);
    spacetime.updateWorldBounds();

    MeshBuffersHandle m = std::make_shared<MeshBuffers>();
    m->V = V;
    m->N = N;

    Surface s;
    s.indices() = F;
    s.setMaterial (material);
    s.addVertexMap (vmap);
    m->S.push_back (s);

    RenderableData d;
    d.clientID = -1;
    d.desc = RenderableDesc();
    d.mesh = m;
    d.name = name;
    d.spacetime = spacetime;

    // add it to the world
    messengers.world.send (QMS::createNewRenderable (d));
}
