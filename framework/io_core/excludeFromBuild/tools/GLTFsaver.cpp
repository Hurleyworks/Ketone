

// This source file was auto-generated by ClassMate++
// Created: 3 May 2020 4:34:01 pm
// Copyright (c) 2020, HurleyWorks

using namespace Microsoft::glTF;
using sabi::PixelBufferHandle;
using sabi::RenderableDesc;
using sabi::VertexMap;
using sabi::VertexMapRef;
using sabi::VertexMapType;

// ctor
GLTFsaver::GLTFsaver()
{
}

// dtor
GLTFsaver::~GLTFsaver()
{
}

void GLTFsaver::serializeMesh (const std::filesystem::path& outputFolder, MeshBuffersHandle& meshToSerialize, const std::string& outputName)
{
    // simple test for valid mesh
    if (!meshToSerialize->pointCount() || !meshToSerialize->triangleCount()) throw std::runtime_error ("Invalid MeshBufferHandle");

    mesh = meshToSerialize;

    // compute vertex normals if they don't exist
    if (mesh->N.cols() == 0)
    {
        MatrixXu allIndices;
        mesh->getAllSurfaceIndices (allIndices);
        
        // FIXME generate_smooth_normals (allIndices, mesh->V, mesh->N, false);
    }

    // Pass the absolute path, without the filename, to the stream writer
    auto streamWriter = std::make_unique<StreamWriter> (outputFolder);
    resourceWriter = std::make_unique<GLTFResourceWriter> (std::move (streamWriter));

    if (!resourceWriter)
    {
        throw std::runtime_error ("Failed to create a ResourceWriter");
    }

    createBuffer (outputName);

    std::string meshId = createMesh();

    // Construct a Node adding a reference to the Mesh
    Node node;
    node.meshId = meshId;

    // Add it to the Document and store the generated ID
    auto nodeId = document.nodes.Append (std::move (node), AppendIdPolicy::GenerateOnEmpty).id;

    // Construct a Scene
    Scene scene;
    scene.nodes.push_back (nodeId);

    // Add it to the Document, using a utility method that also sets the Scene as the Document's default
    document.SetDefaultScene (std::move (scene), AppendIdPolicy::GenerateOnEmpty);

    std::string manifest;
    try
    {
        // Serialize the glTF Document into a JSON manifest
        manifest = Serialize (document, SerializeFlags::Pretty);
    }
    catch (const GLTFException& ex)
    {
        std::stringstream ss;

        ss << "Microsoft::glTF::Serialize failed: ";
        ss << ex.what();

        throw std::runtime_error (ss.str());
    }

    auto& gltfResourceWriter = bufferBuilder->GetResourceWriter();

    // Binary resources have already been written, just need to write the manifest
    std::string out = outputFolder.generic_string() + "/" + outputName + ".gltf";
    gltfResourceWriter.WriteExternal (out, manifest);
}

void GLTFsaver::createBuffer (const std::string& bufferID)
{
    bufferBuilder = std::make_unique<BufferBuilder> (std::move (resourceWriter));

    // Create a Buffer - it will be the 'current' Buffer that all the BufferViews
    // created by this BufferBuilder will automatically reference
    bufferBuilder->AddBuffer (bufferID.c_str());
}

std::string GLTFsaver::createMesh()
{
    // Construct a Mesh and add the MeshPrimitives as a children
    Mesh m;
    m.primitives.reserve (mesh->S.size());

    // create 1 MeshPrimitive per Surface
    for (auto& s : mesh->S)
    {
        MeshPrimitive meshPrimitive;
        meshPrimitive.materialId = createMaterial (s.getMaterial());

        MatrixXf surfaceVertices;
        MatrixXf surfaceVertexNormals;
        meshPrimitive.indicesAccessorId = createIndices (s.indices(), surfaceVertices, surfaceVertexNormals);

        meshPrimitive.attributes[ACCESSOR_POSITION] = createVertices (surfaceVertices);
        meshPrimitive.attributes[ACCESSOR_NORMAL] = createVertexNormals (surfaceVertexNormals);
        if (s.vertexMapCount())
            meshPrimitive.attributes[ACCESSOR_TEXCOORD_0] = createTextureCoords_0 (s.getVMapDB());

        m.primitives.push_back (std::move (meshPrimitive));
    }

    // Add all of the Buffers, BufferViews and Accessors that were created using BufferBuilder to
    // the Document. Note that after this point, no further calls should be made to BufferBuilder
    bufferBuilder->Output (document);

    // Add it to the Document and store the generated ID
    return document.meshes.Append (std::move (m), AppendIdPolicy::GenerateOnEmpty).id;
}

std::string GLTFsaver::createMaterial (sabi::Material& mat)
{
    Microsoft::glTF::Material material;

    material.metallicRoughness.metallicFactor = mat.metallic;
    material.metallicRoughness.roughnessFactor = mat.roughness;
    material.doubleSided = true;

    // DON"T FILL THIS IN IF WE"RE USING A TEXTURE
    if (mat.base_color_tex == nullptr)
        material.metallicRoughness.baseColorFactor = Color4 (mat.base_color.x(), mat.base_color.y(), mat.base_color.z(), mat.base_color.w());

    for (auto img : mat.getTextureImages())
    {
        Image image;
        image.uri = img->spec.fullPath;
        auto imageID = document.images.Append (std::move (image), AppendIdPolicy::GenerateOnEmpty).id;

        Sampler sampler;
        auto samplerID = document.samplers.Append (std::move (sampler), AppendIdPolicy::GenerateOnEmpty).id;

        Microsoft::glTF::Texture texture;
        texture.imageId = imageID;
        texture.samplerId = samplerID;
        auto textureID = document.textures.Append (std::move (texture), AppendIdPolicy::GenerateOnEmpty).id;

        if (img->spec.name == BASE_COLOR_TEXTURE_NAME)
        {
            material.metallicRoughness.baseColorTexture.textureId = textureID;
        }

        if (img->spec.name == METALLIC_ROUGHNESS_TEXTURE_NAME)
        {
            material.metallicRoughness.metallicRoughnessTexture.textureId = textureID;
        }

        if (img->spec.name == NORMAL_MAP_TEXTURE_NAME)
        {
            material.normalTexture.textureId = textureID;
        }
    }

    return document.materials.Append (std::move (material), AppendIdPolicy::GenerateOnEmpty).id;
}

std::string GLTFsaver::createIndices (const MatrixXu& F, MatrixXf& V, MatrixXf& N)
{
    // find the set of unique vertices used in this collection of triangles
    // and remap the indices to them while retaining proper point order
    uint32_t triangleCount = F.cols();
    std::set<uint32_t> s;
    std::vector<uint32_t> v;
    for (int i = 0; i < triangleCount; i++)
    {
        Vector3u tri = F.col (i);
        for (int j = 0; j < 3; j++)
        {
            // std::set sorts it's data and that's not what
            // we want because it changes point order and UV will fail
            auto result = s.insert (tri[j]);
            if (result.second == true)
            {
                // store in vector to retain point order
                v.push_back (tri[j]);
            }
        }
    }

    jassert (s.size() == v.size());

    // get the vertices and map the original index to the new one
    V.resize (3, s.size());
    N.resize (3, s.size());

    uint32_t index = 0;
    std::unordered_map<uint32_t, uint32_t> map;

    // get the vector values not the set values
    // because the set values are sorted and that will
    // mess up UV data
    for (auto i : v)
    {
        map.insert (std::make_pair (i, index));
        //vecStr3f (mesh->V.col (i), DBUG, "AFTER");
        V.col (index) = mesh->V.col (i);
        N.col (index) = mesh->N.col (i);

        ++index;
    }

    // remap indices
    MatrixXu RF;
    RF.resize (3, F.cols());
    for (int i = 0; i < F.cols(); i++)
    {
        Vector3u tri = F.col (i);
        Vector3u tri2;
        auto it = map.find (tri.x());
        if (it != map.end())
        {
            tri2.x() = it->second;
        }
        auto it2 = map.find (tri.y());
        if (it2 != map.end())
        {
            tri2.y() = it2->second;
        }
        auto it3 = map.find (tri.z());
        if (it3 != map.end())
        {
            tri2.z() = it3->second;
        }
        RF.col (i) = tri2;
    }

    // Create a BufferView with a target of ELEMENT_ARRAY_BUFFER (as it will reference index
    // data) - it will be the 'current' BufferView that all the Accessors created by this
    // BufferBuilder will automatically reference
    bufferBuilder->AddBufferView (BufferViewTarget::ELEMENT_ARRAY_BUFFER);

    // Add an Accessor for the indices
    std::vector<uint32_t> indices;
    indices.resize (RF.size());
    std::memcpy (indices.data(), RF.data(), RF.size() * sizeof (uint32_t));

    // Copy the Accessor's id - subsequent calls to AddAccessor may invalidate the returned reference
    return bufferBuilder->AddAccessor (indices, {TYPE_SCALAR, COMPONENT_UNSIGNED_INT}).id;
}

std::string GLTFsaver::createVertices (const MatrixXf& V)
{
    // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
    bufferBuilder->AddBufferView (BufferViewTarget::ARRAY_BUFFER);

    // Add an Accessor for the positions
    std::vector<float> positions;
    positions.resize (V.size());
    std::memcpy (positions.data(), V.data(), V.size() * sizeof (float));

    std::vector<float> minValues (3U, std::numeric_limits<float>::max());
    std::vector<float> maxValues (3U, std::numeric_limits<float>::lowest());

    const size_t positionCount = positions.size();

    // Accessor min/max properties must be set for vertex position data so calculate them here
    for (size_t i = 0U, j = 0U; i < positionCount; ++i, j = (i % 3U))
    {
        minValues[j] = std::min (positions[i], minValues[j]);
        maxValues[j] = std::max (positions[i], maxValues[j]);
    }

    return bufferBuilder->AddAccessor (positions, {TYPE_VEC3, COMPONENT_FLOAT, false, std::move (minValues), std::move (maxValues)}).id;
}

std::string GLTFsaver::createVertexNormals (const MatrixXf& N)
{
    // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
    bufferBuilder->AddBufferView (BufferViewTarget::ARRAY_BUFFER);

    // Add an Accessor for the normals
    std::vector<float> normals;
    normals.resize (N.size());
    std::memcpy (normals.data(), N.data(), N.size() * sizeof (float));

    std::vector<float> minValues (3U, std::numeric_limits<float>::max());
    std::vector<float> maxValues (3U, std::numeric_limits<float>::lowest());

    const size_t positionCount = normals.size();

    // Accessor min/max properties must be set for vertex position data so calculate them here
    for (size_t i = 0U, j = 0U; i < positionCount; ++i, j = (i % 3U))
    {
        minValues[j] = std::min (normals[i], minValues[j]);
        maxValues[j] = std::max (normals[i], maxValues[j]);
    }

    return bufferBuilder->AddAccessor (normals, {TYPE_VEC3, COMPONENT_FLOAT, false, std::move (minValues), std::move (maxValues)}).id;
}

std::string GLTFsaver::createTextureCoords_0 (const VMapDB& vmaps)
{
    for (auto& it : vmaps)
    {
        const VertexMapRef& vmap = it.second;

        // FIXME just UV for now
        if (vmap->type != VertexMapType::UV) continue;

        // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
        bufferBuilder->AddBufferView (BufferViewTarget::ARRAY_BUFFER);

        std::vector<Vector2f> values;

        for (int i = 0; i < vmap->values.cols(); i++)
        {
            bool isMapped = vmap->isMapped (i);
            if (isMapped)
            {
                Vector2f uv = vmap->values.col (i);
               // LOG (DBUG) << " point " << i << "   " << uv.x() << ", " << uv.y();
                values.push_back (uv);
            }
        }

        std::vector<float> uv;
        uv.resize (values.size() * 2);
        std::memcpy (uv.data(), values.data(), values.size() * 2 * sizeof (float));

        //// Add an Accessor for the uv
        //std::vector<float> uv;
        //uv.resize (vmap->values.size());
        //std::memcpy (uv.data(), vmap->values.data(), vmap->values.size() * sizeof (float));

        std::vector<float> minValues (2U, std::numeric_limits<float>::max());
        std::vector<float> maxValues (2U, std::numeric_limits<float>::lowest());

        const size_t positionCount = uv.size();

        // Accessor min/max properties must be set for vertex position data so calculate them here
        for (size_t i = 0U, j = 0U; i < positionCount; ++i, j = (i % 2U))
        {
            minValues[j] = std::min (uv[i], minValues[j]);
            maxValues[j] = std::max (uv[i], maxValues[j]);
        }

        return bufferBuilder->AddAccessor (uv, {TYPE_VEC2, COMPONENT_FLOAT, false, std::move (minValues), std::move (maxValues)}).id;
    }

    return std::string();
}
