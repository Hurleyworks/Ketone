// This source file was auto-generated by ClassMate++
// Created: 28 Feb 2018 8:30:14 am
// Copyright (c) 2018, HurleyWorks

#include "IO.h"

using juce::File;
using juce::FileInputStream;
using juce::FileOutputStream;
using juce::Result;
using juce::String;
using juce::StringArray;
using namespace sabi;
using sabi::Material;

MessageService IO::staticMessengers;

// init
void IO::init (MessageService messengers, const PropertyService& properties)
{
    staticMessengers = messengers;
    this->properties = properties;

    threadPool = OIIO::default_thread_pool();
}

// tick
void IO::tick (size_t frameNumber)
{
}

// loadMesh
void IO::loadMesh (const std::string& path, MeshOptions options)
{
    File f (path);
    if (f.isDirectory())
    {
        loadMeshFolder (path, options);
        return;
    }

    if (!f.existsAsFile())
    {
        std::string err = "Could not find: " + path;
        throw std::runtime_error (err);
    }

    std::string filename = f.getFullPathName().toStdString();
    threadPool->push (&IO::loadMesAsynch, filename, options, RenderableData(), false);
}

void IO::loadMeshFolder (const std::string& path, MeshOptions options)
{
    File folder (path);
    if (!folder.isDirectory()) return;

    StringArray files;
    String wildCard ("*.ply;*.obj;*.gltf;*.lwo");
    FileServices::getFiles (folder.getFullPathName(), files, wildCard);

    for (auto path : files)
    {
        File f (path);
        std::string filename = f.getFullPathName().toStdString();
        threadPool->push (&IO::loadMesAsynch, filename, options, RenderableData(), false);
    }
}

void IO::loadMesAsynch (int thread_id, const std::string& pathToMesh, MeshOptions options, RenderableData& data, bool loadFromScene)
{
    File f (pathToMesh);
    if (!f.existsAsFile())
        throw std::runtime_error ("File not found: " + pathToMesh);

    String ext = f.getFileExtension();

    data.name = f.getFileNameWithoutExtension().toStdString();

    if (ext.equalsIgnoreCase (".ply"))
    {
        loadPLY (pathToMesh, options, data, loadFromScene);
    }
    else if (ext.equalsIgnoreCase (".obj"))
    {
        loadOBJ (pathToMesh, options, data, loadFromScene);
    }
    else if (ext.equalsIgnoreCase (".gltf")) // || ext.equalsIgnoreCase (".glb"))
    {
        loadGLTF (pathToMesh, options, data, loadFromScene);
    }
}

void IO::loadOBJ (const std::string& pathToMesh, MeshOptions options, RenderableData& data, bool loadFromScene)
{
    
}

void IO::loadPLY (const std::string& pathToMesh, MeshOptions options, RenderableData& data, bool loadFromScene)
{
}

void IO::loadGLTF (const std::string& pathToMesh, MeshOptions options, RenderableData& data, bool loadFromScene)
{
    LoadData loadData;
    File f (pathToMesh);

    GLTFloader loader;
    loader.load (pathToMesh, loadData);

    for (auto& d : loadData)
    {
        d.meshOptions = options;
        d.desc.fullFilePath = pathToMesh;
        d.name = f.getFileNameWithoutExtension().toStdString();
    }

    staticMessengers.geometry.send (QMS::processLoadData (std::move (loadData)));
}
