// This source file was auto-generated by ClassMate++
// Created: 26 Jan 2019 8:47:47 pm
// Copyright (c) 2019, HurleyWorks

#include "berserkpch.h"
#include "App.h"

namespace Jahley
{
    App::App (DesktopWindowSettings settings, bool windowApp) :
        windowApp (windowApp),
        errorCallback (std::bind (&App::onFatalError, this, std::placeholders::_1)),
        preCrashCallback (std::bind (&App::preCrash, this)),
        log (errorCallback, preCrashCallback),
        refreshWait (settings.refreshRate)
    {
        resetProperties();

        if (windowApp)
        {
            try
            {
                window = std::make_unique<OpenglWindow> (input);
                window->create (Vector2i (settings.width, settings.height), settings.name, settings.resizable);

                // broadcast InputHandler events to the render layers
                connect (input, &InputHandler::onEvent, *this, &App::onInputEvent);

                // send drop to client to handle
                connect (input, &InputHandler::onDragAndDrop, *this, &App::onDrop);

                // handle window resize
                connect (input, &InputHandler::windowResize, *this, &App::onWindowResize);
            }
            catch (std::exception& e)
            {
                LOG (CRITICAL) << e.what();
            }
            catch (...)
            {
                LOG (CRITICAL) << "Caught unknown exception!";
            }
        }
    }

    App::~App()
    {
    }

    void App::run()
    {
        // let the client initialize
        onInit();

        while (input.windowIsOpen())
        {
            window->renderBegin (properties.renderProps->getVal<Vector4f> (RenderKey::BackgroundColor));

            for (RenderLayerRef layer : layers)
            {
                layer->onUpdate();

                if (layer->getType() == LayerType::Optix && layer->isAttached())
                {
                    PixelBuffer& pixelBuffer = camera->getPixelBuffer();
                    if (pixelBuffer.uint8Pixels.size() || pixelBuffer.floatPixels.size())
                    {
                        window->renderImage (std::move (pixelBuffer));
                    }
                }
            }

            // let the client update
            update();

            window->renderEnd (true); // true means glfw will wait for events instead of polling

            // post an empty event to GLFW after waiting
            // for user defined amount of time
            std::this_thread::sleep_for (refreshWait);

            glfwPostEmptyEvent();
        }

        window.reset();
    }

    void App::pushLayer (RenderLayerRef layer, bool attach)
    {
        layers.pushLayer (layer);
        if (attach)
            layer->onAttach();
    }

    void App::pushOverlay (RenderLayerRef layer, bool attach)
    {
        layers.pushOverlay (layer);
        if (attach)
            layer->onAttach();
    }

    void App::onInputEvent (InputEvent input)
    {
        for (RenderLayerRef layer : layers)
        {
            if ((layer->getType() == LayerType::Nanogui))
            {
                bool sendToClient = true;

                // eat the input if the gui is being used
                if (layer->onInput (input))
                {
                    sendToClient = false;
                }

                // maybe send to client
                if (sendToClient)
                {
                    onInput (input);
                }
            }
        }
    }

    void App::resetProperties()
    {
        // FIXME mayber this belongs in client code?

        // world properties
        properties.worldProps->addDefault (WorldKey::TotalMeshes, DEFAULT_MESH_COUNT);
        properties.worldProps->addDefault (WorldKey::TotalInstances, DEFAULT_INSTANCES_COUNT);
        properties.worldProps->addDefault (WorldKey::TotalRealTriangles, DEFAULT_TRIANGLE_COUNT);
        properties.worldProps->addDefault (WorldKey::TotalInstancedTriangles, DEFAULT_INSTANCED_TRIANGLE_COUNT);
        properties.worldProps->addDefault (WorldKey::MotionType, DEFAULT_MOTION_TYPE);
        properties.worldProps->addDefault (WorldKey::RandomInstanceScale, DEFAULT_RANOOM_INSTANCE_SCALE);
        properties.worldProps->addDefault (WorldKey::RandomInstanceMaterial, DEFAULT_RANDOM_INSTANCE_MATERIAL);

        // render properties
        properties.renderProps->addDefault (RenderKey::ShowPerformanceGraph, true);
        properties.renderProps->addDefault (RenderKey::BackgroundColor, DEFAULT_DESKTOP_WINDOW_BACKGROUND_COLOR);
        properties.renderProps->addDefault (RenderKey::RenderTime, double (0.0));
        properties.renderProps->addDefault (RenderKey::ResourceFolder, INVALID_PATH);
        properties.renderProps->addDefault (RenderKey::CommonFolder, INVALID_PATH);
        properties.renderProps->addDefault(RenderKey::RootFolder, INVALID_PATH);
        properties.renderProps->addDefault (RenderKey::PtxFolder, INVALID_PATH);
        properties.renderProps->addDefault (RenderKey::MotionBlur, DEFAULT_MOTION_BLUR);
        properties.renderProps->addDefault (RenderKey::RenderType, DEFAULT_RENDER_TYPE);
        properties.renderProps->addDefault (RenderKey::RenderOutput, DEFAULT_RENDER_OUTPUT);
    }

    // preCrash
    void App::preCrash()
    {
        // let the client throw up a warning if it can
        onCrash();

#ifndef NDEBUG
#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__))
        __debugbreak();
#endif
#endif
    }

    // onFatalError
    void App::onFatalError (g3::FatalMessagePtr fatal_message)
    {
        LOG (CRITICAL) << fatal_message.get()->toString();

        g3::internal::pushFatalMessageToLogger (fatal_message);
    }
} // namespace Jahley