// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 6:10:35 am
// Copyright (c) 2019, HurleyWorks

#include <stb_image.h>
#include "jahley/window/platform/opengl/OpenglTexture.h"
#include <sabi_core/sabi_core.h>
#include "ActiveFramework.h"
#include "View.h"

using namespace nanogui;
using juce::File;
using juce::String;


// ctor
View::View (const PropertyService& properties) :
    properties (properties)
{
}

// dtor
View::~View()
{
}

void View::create (NanoguiLayer* const gui, const std::string& appName)
{
    commonFolder = properties.renderProps->getVal<std::string> (RenderKey::CommonFolder);
    resourceFolder = properties.renderProps->getVal<std::string> (RenderKey::ResourceFolder);

    this->gui = gui;

    auto ctx = gui->nvgContext();
    Window* window = new Window (gui, appName);
    window->setPosition (Vector2i (15, 15));
    window->setLayout (new GroupLayout());
  
    // load the model icons in the common folder
    modelIcons = loadImageDirectory (ctx, commonFolder + "/models");

    PopupButton* scenePopupBtn = new PopupButton (window, "Scene", ENTYPO_ICON_EXPORT);
    Popup* scenePopup = scenePopupBtn->popup();
    scenePopup->setLayout (new GroupLayout());
    Label* label = new Label (scenePopup, "Scene:", "sans-bold");
    label->setColor (Color (r1, g1, b1, a1));

    {
        PopupButton* imagePanelBtn = new PopupButton (scenePopup, "Models");
        imagePanelBtn->setIcon (ENTYPO_ICON_FOLDER);
        Popup* popup = imagePanelBtn->popup();
        VScrollPanel* vscroll = new VScrollPanel (popup);
        ImagePanel* imgPanel = new ImagePanel (vscroll);
        imgPanel->setImages (modelIcons);
        popup->setFixedSize (Vector2i (440, 150));

        imgPanel->setCallback ([&, imagePanelBtn] (int i) {
            imagePanelBtn->setPushed (false);
            std::string path = modelIcons[i].second;
            path = path + ".png";
            File f (path);
            if (f.existsAsFile())
            {
                emitModelPath (path);
            }
        });
    }

    Button* b = new Button (scenePopup, "Add ground plane");
    b->setCallback ([&] { emitGroundPlane (Vector2f (30.0f, 30.0f)); });
    b->setTooltip ("Add a ground plane");

    label = new Label (window, "Tools", "sans-bold");
    label->setColor (Color (r1, g1, b1, a1));
    PopupButton* meshOps = new PopupButton (window, "Mesh ops", ENTYPO_ICON_EXPORT);
    Popup* popup = meshOps->popup();
    popup->setLayout (new GroupLayout());

    Button* but = popup->add<Button> ("Clump of instances", ENTYPO_ICON_CAKE);
    but->setCallback ([&] {
        int count = stackCount->value();
        // FIXME
        // count = 4;
        emitInstanceClump (count);
    });
    but->setTooltip ("Build a clump from the current items");
    new Label (popup, "Instance count :", "sans-bold");
    stackCount = new IntBox<int> (popup);
    stackCount->setEditable (true);
    stackCount->setFixedSize (Vector2i (100, 20));
    stackCount->setValue (100);
    //stackCount->setUnits("instances");
    stackCount->setDefaultValue ("0");
    stackCount->setFontSize (16);
    stackCount->setFormat ("[1-9][0-9]*");
    stackCount->setSpinnable (true);
    stackCount->setMinValue (1);
    stackCount->setValueIncrement (100);
    CheckBox* cb = new CheckBox (popup, "Random scale",
                                 [] (bool state) {  });
    cb->setChecked (DEFAULT_RANOOM_INSTANCE_SCALE);
    cb = new CheckBox (popup, "Random material",
                       [] (bool state) { });
    cb->setChecked (DEFAULT_RANDOM_INSTANCE_MATERIAL);

    gui->performLayout();
}

const StringArray View::getSceneInfo()
{
    StringArray message;

    uint64_t totalMeshes = properties.worldProps->getVal<uint64_t> (WorldKey::TotalMeshes);
    uint64_t totalInstances = properties.worldProps->getVal<uint64_t> (WorldKey::TotalInstances);
    uint64_t totalInstancedTriangles = properties.worldProps->getVal<uint64_t> (WorldKey::TotalInstancedTriangles);
    uint64_t totalTriangles = properties.worldProps->getVal<uint64_t> (WorldKey::TotalRealTriangles);

    message.add (String ("Total meshes: ") + String (totalMeshes));
    message.add (String ("Total instances: ") + String (totalInstances));
    message.add (String ("Total mesh triangles: ") + String (totalTriangles));
    message.add (String ("Total instanced triangles: ") + String (totalInstancedTriangles));

    return message;
}
