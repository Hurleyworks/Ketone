// This header file was auto-generated by ClassMate++
// Created: 22 Feb 2019 8:55:26 pm
// Copyright (c) 2019, HurleyWorks

#pragma once

// NO MORE TRACING  Yay
#define TRACE(x)

const LEVELS TESTING{INFO.value + 1, "TESTING"};
const LEVELS CRITICAL{WARNING.value + 1, "CRTICAL"};

#if defined(_WIN32) || defined(_WIN64)
#define __FUNCTION_NAME__ __FUNCTION__
#define _FN_ __FUNCTION_NAME__
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>
#undef near
#undef far
#undef RGB
#endif

#define BIT(x) (1 << x)

enum class ImageDataType
{
    UINT8_DATA,
    FLOAT_DATA
};

struct ImageInfo
{
    ImageDataType dataType = ImageDataType::UINT8_DATA;
    int width = DEFAULT_MIN_WINDOW;
    int height = DEFAULT_MIN_WINDOW;
    int resizedWidth = INVALID_IMAGE_SIZE;
    int resizedHeight = INVALID_IMAGE_SIZE;
    int channels = DEFAULT_CHANNELS;
    std::string name = INVALID_NAME;
    std::string fullPath = INVALID_PATH;
    bool ready = false;
    bool dirty = false;
};

static const char* RenderModeTable[] =
    {
        "DebugRender",
        "PathTracer",
       
        "Invalid"};

struct RenderMode
{
    enum ERenderMode
    {
        DebugRender,
        PathTracer,
        Count,
        Invalid = Count
    };

    union
    {
        ERenderMode name;
        unsigned int value;
    };

    RenderMode (ERenderMode name) :
        name (name) {}
    RenderMode (unsigned int value) :
        value (value) {}
    RenderMode() :
        value (Invalid) {}
    operator ERenderMode() const { return name; }
    const char* ToString() const { return RenderModeTable[value]; }
};

static const char* RenderOutputTable[] =
    {
        "Color",
        "ColorDenoised",
        "Albedo",
        "Normal",
        "Invalid"};

struct RenderOutput
{
    enum ERenderOutput
    {
        Color,
        ColorDenoised,
        Albedo,
        Normal,
        Count,
        Invalid = Count
    };

    union
    {
        ERenderOutput name;
        unsigned int value;
    };

    RenderOutput (ERenderOutput name) :
        name (name) {}
    RenderOutput (unsigned int value) :
        value (value) {}
    RenderOutput() :
        value (Invalid) {}
    operator ERenderOutput() const { return name; }
    const char* toString() const { return RenderOutputTable[value]; }
};

// rational.cpp by Bill Weinman <http://bw.org/>
// updated 2015-06-01
inline void message (const char* s)
{
    puts (s);
    fflush (stdout);
}

enum ErrorSeverity
{
    Information,
    Warning,
    Critical,
};

struct ErrMsg
{
    std::string message = "";
    ErrorSeverity severity = ErrorSeverity::Information;
};



// from InstantMeshes https://github.com/wjakob/instant-meshes
inline bool atomicCompareAndExchange (volatile uint32_t* v, uint32_t newValue, uint32_t oldValue)
{
#if defined(_WIN32)
    return _InterlockedCompareExchange (
               reinterpret_cast<volatile long*> (v), (long)newValue, (long)oldValue) == (long)oldValue;
#else
    return __sync_bool_compare_and_swap (v, oldValue, newValue);
#endif
}

inline uint32_t atomicAdd (volatile uint32_t* dst, uint32_t delta)
{
#if defined(_MSC_VER)
    return _InterlockedExchangeAdd (reinterpret_cast<volatile long*> (dst), delta) + delta;
#else
    return __sync_add_and_fetch (dst, delta);
#endif
}

inline float atomicAdd (volatile float* dst, float delta)
{
    union bits
    {
        float f;
        uint32_t i;
    };
    bits oldVal, newVal;
    do
    {
#if defined(__i386__) || defined(__amd64__)
        __asm__ __volatile__("pause\n");
#endif
        oldVal.f = *dst;
        newVal.f = oldVal.f + delta;
    } while (!atomicCompareAndExchange ((volatile uint32_t*)dst, newVal.i, oldVal.i));
    return newVal.f;
}