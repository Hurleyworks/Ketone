// This header file was auto-generated by ClassMate++
// Created: 9 May 2019 6:32:48 am
// Copyright (c) 2019, HurleyWorks

#pragma once

using Eigen::Affine3f;
using Eigen::AngleAxisf;
using Eigen::Matrix4f;
using Eigen::Quaternionf;
using Eigen::Translation3f;
using Eigen::Vector2f;
using Eigen::Vector2i;
using Eigen::Vector3f;
using wabi::Ray3f;
using sabi::PixelBufferHandle;

using CameraHandle = std::shared_ptr<class ActiveCam>;


class Frame
{
 public:
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW

    inline Frame (const Eigen::Vector3f& pos = Eigen::Vector3f::Zero(),
                  const Eigen::Quaternionf& o = Eigen::Quaternionf()) :
        orientation (o),
        position (pos)
    {
    }
    Frame lerp (float alpha, const Frame& other) const
    {
        return Frame ((1.f - alpha) * position + alpha * other.position,
                      orientation.slerp (alpha, other.orientation));
    }

    Eigen::Quaternionf orientation;
    Eigen::Vector3f position;
};

class ActiveCam
{
 public:
    ~ActiveCam();

    // viewport
    void setScreenSize (const Vector2f& size)
    {
        if (screenSize != size)
        {
            jassert (size.x() > 0.0f && size.y() > 0.0f);
            screenSize = size;
            aspect = size.x() / size.y();
        }
    }
    Vector2f getScreenSize() const { return screenSize; }
    float getScreenWidth() const { return screenSize.x(); }
    float getScreenHeight() const { return screenSize.y(); }

    void lookAt (const Vector3f& eyePoint, const Vector3f& target, const Vector3f& up);
    void lookAt (const Vector3f& eyePoint, const Vector3f& target);
    void setEyePoint (const Vector3f& eyePoint)
    {
        eye = eyePoint;
        viewMatrixCached = false;
    }

    void setPosition (const Vector3f& p)
    {
        frame.position = p;
        viewMatrixCached = false;
    }
    void setTarget (const Vector3f& target);
    void setDirection (const Vector3f& newDirection);
    void setOrientation (const Matrix3f& linear)
    {
        frame.orientation = Quaternionf (linear);
        orientation = Quaternionf (linear);
        viewMatrixCached = false;
    }

    void setOrientation (const Quaternionf& q)
    {
        frame.orientation = q;
        viewMatrixCached = false;
    }

    const Vector3f& getEyePoint() const { return eye; }
    const Vector3f& getWorldUp() const { return worldUp; }
    const Vector3f& getUp() const { return mV; }
    const Vector3f& getRight() const { return mU; }
    const Vector3f& getFoward() const { return forward; }
    const Vector3f& getTarget() const { return target; }
    const Vector3f& getViewDirection() const { return viewDirection; }
    const Quaternionf& getOrientation() const { return orientation; }

    float getFOV() const { return fovDegrees; }
    float getAspect() const { return aspect; }

    void rotateAroundTarget (const Quaternionf& q);
    void zoom (float d);

    const Affine3f& getViewTransform() const
    {
        if (!viewMatrixCached) calcViewMatrix();
        return viewMatrix;
    }

    const Matrix4f& getViewMatrix() const
    {
        if (!viewMatrixCached) calcViewMatrix();
        return viewMatrix.matrix();
    }

    void setViewMatrix (const Matrix4f& m)
    {
        viewMatrix.matrix() = m;
        viewMatrixCached = true;
    }
    const Matrix4f& getInverseViewMatrix() const
    {
        if (!inverseModelViewCached) calcInverseView();
        return inverseModelViewMatrix;
    }
    const Matrix4f& getProjectionMatrix() const
    {
        if (!projectionCached) calcProjection();
        return projectionMatrix;
    }

   void setProjectionMatrix (const Matrix4f& m)
    {
       projectionMatrix = m;
        projectionCached = true;
    }

    // from Cinder https://libcinder.org/
    Ray3f generateRay (float u, float v, float imagePlaneAspectRatio) const { return calcRay (u, v, imagePlaneAspectRatio); }
    Ray3f generateRay (const Vector2f& posPixels, const Vector2f& imageSizePixels) const
    {
        return calcRay (posPixels.x() / imageSizePixels.x(), (imageSizePixels.y() - posPixels.y()) / imageSizePixels.y(), imageSizePixels.x() / imageSizePixels.y());
    }

    void getFrustum (float* left, float* top, float* right, float* bottom, float* nearVal, float* farVal) const;

    virtual void setPerspective (float verticalFovDegrees, float aspectRatio, float nearPlane, float farPlane) {}
    virtual bool isPersp() const = 0;

    bool isDirty() const { return dirty; }
    void setDirty (bool state) { dirty = state; }

    // trackball
    void startTracking() { lastPointOK = false; }
    void track (const Vector2f& newPoint2D);

    // PixelBuffer
    PixelBuffer& getPixelBuffer() { return pixelBuffer; }
    PixelBufferHandle getFinalBuffer() { return finalRender; }
    void setFinalRender (PixelBufferHandle&& render) { finalRender = std::move(render); }
    uint32_t getPases() const { return passes; }
    void setPasses (uint32_t passCount) { passes = passCount; }
    bool getPassesComplete() const { return passesComplete; }
    void setPassesComplete (bool state) { passesComplete = state; }

    void setFrame (const Frame& f);
    const Frame& getFrame() const { return frame; }

 protected:
    ActiveCam() :
        viewMatrixCached (false),
        projectionCached (false),
        inverseModelViewCached (false),
        worldUp (Vector3f::UnitY())
    {
    }

    void calcMatrices() const;
    virtual void calcViewMatrix() const;
    virtual void calcInverseView() const;
    virtual void calcProjection() const = 0;
    virtual wabi::Ray3f calcRay (float uPos, float vPos, float imagePlaneAspectRatio) const;

    // trackball
    bool mapToSphere (const Vector2f& p2, Vector3f& v3);
    Vector3f lastPoint3D = Vector3f::Zero();
    bool lastPointOK = false;

    bool dirty = true;
    Vector2f screenSize = Vector2f (DEFAULT_DESKTOP_WINDOW_WIDTH, DEFAULT_DESKTOP_WINDOW_HEIGHT);
    Vector3f eye = DEFAULT_CAMERA_POSIIION;
    Vector3f viewDirection = Vector3f::UnitZ();
    mutable Vector3f forward = Vector3f::UnitX();
    Quaternionf orientation;
    Vector3f worldUp = Vector3f::UnitY();
    Vector3f target = Vector3f::Zero();

    Frame frame;
    float fovDegrees = DEFAULT_FOV_DEGREES;
    float aspect = DEFAULT_ASPECT;
    float nearClip = DEFAULT_NEAR_PLANE;
    float farClip = DEFAULT_FAR_PLANE;

    mutable Vector3f mU; // Right vector
    mutable Vector3f mV; // Readjust up-vector
    mutable Vector3f mW; // Negative view direction

    mutable Matrix4f projectionMatrix, inverseProjectionMatrix;
    mutable bool projectionCached;
    mutable Affine3f viewMatrix;
    mutable bool viewMatrixCached;
    mutable Matrix4f inverseModelViewMatrix;
    mutable bool inverseModelViewCached;

    mutable float frustumLeft, frustumRight, frustumTop, frustumButtom;

    PixelBuffer pixelBuffer; // store the render through the camera
    PixelBufferHandle finalRender = nullptr;
    uint32_t passes = 0;
    bool passesComplete = false;

}; // end class ActiveCam

using PerspectiveCamHandle = std::shared_ptr<class PerspectiveCam>;

class PerspectiveCam : public ActiveCam
{
 public:
    static CameraHandle create() { return std::make_shared<PerspectiveCam>(); }

 public:
    PerspectiveCam();
    PerspectiveCam (int pixelWidth, int pixelHeight, float fovDegrees);
    PerspectiveCam (int pixelWidth, int pixelHeight, float fovDegrees, float nearPlane, float farPlane);

    void setPerspective (float verticalFovDegrees, float aspectRatio, float nearPlane, float farPlane) override;
    bool isPersp() const override { return true; }

 protected:
    void calcProjection() const override;
};