// This header file was auto-generated by ClassMate++
// Created: 16 Sep 2017 5:37:16 pm
// Copyright (c) 2017, HurleyWorks

#pragma once

using Eigen::Affine3f;
using Eigen::AlignedBox3f;
using Eigen::Vector3f;

class SpaceTime 
{

 public:
	SpaceTime ();
	~SpaceTime() = default;

	void reset();
		
	Affine3f startTransform;
	Affine3f localTransform;
	Affine3f worldTransform;
	Affine3f previousWorldTransform;

	AlignedBox3f modelBound;
	AlignedBox3f worldBound;

	Vector3f scale;
	Vector3f previousScale;

	Vector3f modeledOffset;
	Vector3f centerOfVertexMass;

	std::chrono::time_point<std::chrono::system_clock> birth;
	std::chrono::duration<double> getLifeSpan();

	bool is2D() const;
	bool hasModeledOffset() const { return modeledOffset.norm() > std::numeric_limits<float>::epsilon(); }
	void updateWorldBounds(bool includeScale = false);
	void updateLocalBounds(bool includeScale = false);
	void makeCurrentPoseStartPose() { startTransform = worldTransform; }
	void resetMotion() { worldTransform = startTransform; }

	bool convertToRightHandCoordinateSystem = false;

	void debug()
	{
		mace::matStr4f(startTransform, DBUG, "Start transform");
        mace::matStr4f (localTransform, DBUG, "Local transform");
        mace::matStr4f (worldTransform, DBUG, "World transform");
        mace::matStr4f (previousWorldTransform, DBUG, "Previous world transform");

		mace::vecStr3f (scale, DBUG, "Scale");
        mace::vecStr3f (previousScale, DBUG, "Previous scale");

		mace::vecStr3f (modelBound.min(), DBUG, "ModelBound min");
        mace::vecStr3f (modelBound.max(), DBUG, "ModelBound max");

		mace::vecStr3f (worldBound.min(), DBUG, "WorldBound min");
        mace::vecStr3f (worldBound.max(), DBUG, "WorlddBound max");

		mace::vecStr3f (modeledOffset, DBUG, "Modeled offset");
        mace::vecStr3f (centerOfVertexMass, DBUG, "Center of vertex mass");
		
	}

}; // end class SpaceTime
